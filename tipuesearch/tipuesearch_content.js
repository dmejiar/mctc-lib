var tipuesearch = {"pages":[{"title":" MCTC-library ","text":"MCTC-library Common tool chain to molecular structure data in various applications developed in our group. Getting Started Meson Create a new meson project and include mctc-lib either as git-submodule in your subprojects directory or create a wrap file to fetch it from upstream: [wrap-git] directory = mctc-lib url = https://github.com/grimme-lab/mctc-lib revision = head To load the project the necessary boilerplate code for subprojects is just mctc_prj = subproject ( 'mctc-lib' , version : '>=0.1' , default_options : [ 'default_library=static' , ], ) mctc_dep = mctc_prj . get_variable ( 'mctc_dep' ) Now you can add mctc_dep to your dependencies and access the public API by the mctc module. We recommend to set the default library type of mctc-lib to static when linking your applications or library against it.\nNote for library type both and shared mctc-lib will install itself along with your project. For more fine-tuned control you can access: the library target with mctc_lib the private include dir of this target, containing the Fortran module files, with mctc_inc the license files of mctc-lib with mctc_lic If you are linking your application statically against mctc-lib and still want to distribute the license files of mctc-lib (thank you), just use install_data ( mctc_prj . get_variable ( 'mctc_lic' ), install_dir : get_option ( 'datadir' ) / 'licenses' / meson . project_name () / 'mctc-lib' , ) Fortran Package Manager (fpm) This project supports fpm as build system as well.\nJust add it to the dependencies in your fpm.toml file: [dependencies] [dependencies.mctc-lib] git = \"https://github.com/grimme-lab/mctc-lib\" Developer Info Grimme group, Bonn","tags":"home","loc":"index.html"},{"title":"io.f90 – MCTC-library","text":"Contents Modules mctc_io Source Code io.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io use mctc_io_filetype , only : filetype , get_filetype use mctc_io_read , only : read_structure use mctc_io_structure , only : structure_type , new_structure use mctc_io_write , only : write_structure implicit none private public :: filetype , get_filetype public :: read_structure , write_structure public :: structure_type , new_structure contains end module mctc_io","tags":"","loc":"sourcefile/io.f90.html"},{"title":"env.f90 – MCTC-library","text":"Contents Modules mctc_env Source Code env.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Public API reexport of environment library module mctc_env use mctc_env_accuracy , only : sp , dp , wp , i1 , i2 , i4 , i8 use mctc_env_error , only : error_type , fatal_error , mctc_stat implicit none public end module mctc_env","tags":"","loc":"sourcefile/env.f90.html"},{"title":"version.f90 – MCTC-library","text":"Contents Modules mctc_version Source Code version.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_version implicit none private public :: mctc_version_string , mctc_version_compact public :: get_mctc_version !> String representation of the mctc-lib version character ( len =* ), parameter :: mctc_version_string = \"0.1.1\" !> Numeric representation of the mctc-lib version integer , parameter :: mctc_version_compact ( 3 ) = [ 0 , 1 , 1 ] contains !> Getter function to retrieve mctc-lib version subroutine get_mctc_version ( major , minor , patch , string ) !> Major version number of the mctc-lib version integer , intent ( out ), optional :: major !> Minor version number of the mctc-lib version integer , intent ( out ), optional :: minor !> Patch version number of the mctc-lib version integer , intent ( out ), optional :: patch !> String representation of the mctc-lib version character ( len = :), allocatable , intent ( out ), optional :: string if ( present ( major )) then major = mctc_version_compact ( 1 ) end if if ( present ( minor )) then minor = mctc_version_compact ( 2 ) end if if ( present ( patch )) then patch = mctc_version_compact ( 3 ) end if if ( present ( string )) then string = mctc_version_string end if end subroutine get_mctc_version end module mctc_version","tags":"","loc":"sourcefile/version.f90.html"},{"title":"accuracy.f90 – MCTC-library","text":"Contents Modules mctc_env_accuracy Source Code accuracy.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Numerical storage size parameters for real and integer values module mctc_env_accuracy implicit none public !> Single precision real numbers integer , parameter :: sp = selected_real_kind ( 6 ) !> Double precision real numbers integer , parameter :: dp = selected_real_kind ( 15 ) !> Wanted precision integer , parameter :: wp = dp !> Char length for integers integer , parameter :: i1 = selected_int_kind ( 2 ) !> Short length for integers integer , parameter :: i2 = selected_int_kind ( 4 ) !> Length of default integers integer , parameter :: i4 = selected_int_kind ( 9 ) !> Long length for integers integer , parameter :: i8 = selected_int_kind ( 18 ) end module mctc_env_accuracy","tags":"","loc":"sourcefile/accuracy.f90.html"},{"title":"testing.f90 – MCTC-library","text":"Contents Modules mctc_env_testing Source Code testing.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_env_testing use mctc_env_error , only : error_type , mctc_stat use mctc_env_accuracy , only : sp , dp , i1 , i2 , i4 , i8 implicit none private public :: run_testsuite , run_selected , new_unittest , new_testsuite public :: select_test , select_suite public :: unittest_type , testsuite_type , error_type public :: check , test_failed interface check module procedure :: check_stat module procedure :: check_float_sp module procedure :: check_float_dp module procedure :: check_int_i1 module procedure :: check_int_i2 module procedure :: check_int_i4 module procedure :: check_int_i8 module procedure :: check_bool module procedure :: check_string end interface check abstract interface !> Entry point for tests subroutine test_interface ( error ) import :: error_type !> Error handling type ( error_type ), allocatable , intent ( out ) :: error end subroutine test_interface end interface !> Declaration of a unit test type :: unittest_type !> Name of the test character ( len = :), allocatable :: name !> Entry point of the test procedure ( test_interface ), pointer , nopass :: test => null () !> Whether test is supposed to fail logical :: should_fail = . false . end type unittest_type abstract interface !> Collect all tests subroutine collect_interface ( testsuite ) import :: unittest_type !> Collection of tests type ( unittest_type ), allocatable , intent ( out ) :: testsuite (:) end subroutine collect_interface end interface !> Collection of unit tests type :: testsuite_type !> Name of the testsuite character ( len = :), allocatable :: name !> Entry point of the test procedure ( collect_interface ), pointer , nopass :: collect => null () end type testsuite_type character ( len =* ), parameter :: fmt = '(1x, *(1x, a))' character ( len =* ), parameter :: indent = repeat ( \" \" , 5 ) // repeat ( \".\" , 3 ) contains !> Driver for testsuite subroutine run_testsuite ( collect , unit , stat ) !> Collect tests procedure ( collect_interface ) :: collect !> Unit for IO integer , intent ( in ) :: unit !> Number of failed tests integer , intent ( inout ) :: stat type ( unittest_type ), allocatable :: testsuite (:) integer :: ii call collect ( testsuite ) !$omp parallel do shared(testsuite, unit) reduction(+:stat) do ii = 1 , size ( testsuite ) !$omp critical(mctc_env_testsuite) write ( unit , '(1x, 3(1x, a), 1x, \"(\", i0, \"/\", i0, \")\")' ) & & \"Starting\" , testsuite ( ii )% name , \"...\" , ii , size ( testsuite ) !$omp end critical(mctc_env_testsuite) call run_unittest ( testsuite ( ii ), unit , stat ) end do end subroutine run_testsuite !> Driver for selective testing subroutine run_selected ( collect , name , unit , stat ) !> Collect tests procedure ( collect_interface ) :: collect !> Name of the selected test character ( len =* ), intent ( in ) :: name !> Unit for IO integer , intent ( in ) :: unit !> Number of failed tests integer , intent ( inout ) :: stat type ( unittest_type ), allocatable :: testsuite (:) integer :: ii call collect ( testsuite ) ii = select_test ( testsuite , name ) if ( ii > 0 . and . ii <= size ( testsuite )) then call run_unittest ( testsuite ( ii ), unit , stat ) else write ( unit , fmt ) \"Available tests:\" do ii = 1 , size ( testsuite ) write ( unit , fmt ) \"-\" , testsuite ( ii )% name end do stat = - huge ( ii ) end if end subroutine run_selected !> Run a selected unit test subroutine run_unittest ( test , unit , stat ) !> Unit test type ( unittest_type ), intent ( in ) :: test !> Unit for IO integer , intent ( in ) :: unit !> Number of failed tests integer , intent ( inout ) :: stat type ( error_type ), allocatable :: error call test % test ( error ) !$omp critical(mctc_env_testsuite) if ( allocated ( error ) . neqv . test % should_fail ) then if ( test % should_fail ) then write ( unit , fmt ) indent , test % name , \"[UNEXPECTED PASS]\" else write ( unit , fmt ) indent , test % name , \"[FAILED]\" end if stat = stat + 1 else if ( test % should_fail ) then write ( unit , fmt ) indent , test % name , \"[EXPECTED FAIL]\" else write ( unit , fmt ) indent , test % name , \"[PASSED]\" end if end if if ( allocated ( error )) then write ( unit , fmt ) \"Message:\" , error % message end if !$omp end critical(mctc_env_testsuite) end subroutine run_unittest !> Select a unit test from all available tests function select_test ( tests , name ) result ( pos ) !> Name identifying the test suite character ( len =* ), intent ( in ) :: name !> Available unit tests type ( unittest_type ) :: tests (:) !> Selected test suite integer :: pos integer :: it pos = 0 do it = 1 , size ( tests ) if ( name == tests ( it )% name ) then pos = it exit end if end do end function select_test !> Select a test suite from all available suites function select_suite ( suites , name ) result ( pos ) !> Name identifying the test suite character ( len =* ), intent ( in ) :: name !> Available test suites type ( testsuite_type ) :: suites (:) !> Selected test suite integer :: pos integer :: it pos = 0 do it = 1 , size ( suites ) if ( name == suites ( it )% name ) then pos = it exit end if end do end function select_suite !> Register a new unit test function new_unittest ( name , test , should_fail ) result ( self ) !> Name of the test character ( len =* ), intent ( in ) :: name !> Entry point for the test procedure ( test_interface ) :: test !> Whether test is supposed to error or not logical , intent ( in ), optional :: should_fail !> Newly registered test type ( unittest_type ) :: self self % name = name self % test => test if ( present ( should_fail )) self % should_fail = should_fail end function new_unittest !> Register a new testsuite function new_testsuite ( name , collect ) result ( self ) !> Name of the testsuite character ( len =* ), intent ( in ) :: name !> Entry point to collect tests procedure ( collect_interface ) :: collect !> Newly registered testsuite type ( testsuite_type ) :: self self % name = name self % collect => collect end function new_testsuite subroutine check_stat ( error , stat , message , more ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> Status of operation integer , intent ( in ) :: stat !> A detailed message describing the error character ( len =* ), intent ( in ), optional :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more if ( stat /= mctc_stat % success ) then if ( present ( message )) then call test_failed ( error , message , more ) else call test_failed ( error , \"Non-zero exit code encountered\" , more ) end if end if end subroutine check_stat subroutine check_float_dp ( error , actual , expected , message , more , thr , rel ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> Found floating point value real ( dp ), intent ( in ) :: actual !> Expected floating point value real ( dp ), intent ( in ) :: expected !> A detailed message describing the error character ( len =* ), intent ( in ), optional :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more !> Allowed threshold for matching floating point values real ( dp ), intent ( in ), optional :: thr !> Check for relative errors instead logical , intent ( in ), optional :: rel logical :: relative real ( dp ) :: diff , threshold if ( present ( thr )) then threshold = thr else threshold = epsilon ( expected ) end if if ( present ( rel )) then relative = rel else relative = . false . end if if ( relative ) then diff = abs ( actual - expected ) / expected else diff = abs ( actual - expected ) end if if ( diff > threshold ) then if ( present ( message )) then call test_failed ( error , message , more ) else call test_failed ( error , \"Floating point value missmatch\" , more ) end if end if end subroutine check_float_dp subroutine check_float_sp ( error , actual , expected , message , more , thr , rel ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> Found floating point value real ( sp ), intent ( in ) :: actual !> Expected floating point value real ( sp ), intent ( in ) :: expected !> A detailed message describing the error character ( len =* ), intent ( in ), optional :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more !> Allowed threshold for matching floating point values real ( sp ), intent ( in ), optional :: thr !> Check for relative errors instead logical , intent ( in ), optional :: rel logical :: relative real ( sp ) :: diff , threshold if ( present ( thr )) then threshold = thr else threshold = epsilon ( expected ) end if if ( present ( rel )) then relative = rel else relative = . false . end if if ( relative ) then diff = abs ( actual - expected ) / expected else diff = abs ( actual - expected ) end if if ( diff > threshold ) then if ( present ( message )) then call test_failed ( error , message , more ) else call test_failed ( error , \"Floating point value missmatch\" , more ) end if end if end subroutine check_float_sp subroutine check_int_i1 ( error , actual , expected , message , more ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> Found integer value integer ( i1 ), intent ( in ) :: actual !> Expected integer value integer ( i1 ), intent ( in ) :: expected !> A detailed message describing the error character ( len =* ), intent ( in ), optional :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more if ( expected /= actual ) then if ( present ( message )) then call test_failed ( error , message , more ) else call test_failed ( error , \"Integer value missmatch\" , more ) end if end if end subroutine check_int_i1 subroutine check_int_i2 ( error , actual , expected , message , more ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> Found integer value integer ( i2 ), intent ( in ) :: actual !> Expected integer value integer ( i2 ), intent ( in ) :: expected !> A detailed message describing the error character ( len =* ), intent ( in ), optional :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more if ( expected /= actual ) then if ( present ( message )) then call test_failed ( error , message , more ) else call test_failed ( error , \"Integer value missmatch\" , more ) end if end if end subroutine check_int_i2 subroutine check_int_i4 ( error , actual , expected , message , more ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> Found integer value integer ( i4 ), intent ( in ) :: actual !> Expected integer value integer ( i4 ), intent ( in ) :: expected !> A detailed message describing the error character ( len =* ), intent ( in ), optional :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more if ( expected /= actual ) then if ( present ( message )) then call test_failed ( error , message , more ) else call test_failed ( error , \"Integer value missmatch\" , more ) end if end if end subroutine check_int_i4 subroutine check_int_i8 ( error , actual , expected , message , more ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> Found integer value integer ( i8 ), intent ( in ) :: actual !> Expected integer value integer ( i8 ), intent ( in ) :: expected !> A detailed message describing the error character ( len =* ), intent ( in ), optional :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more if ( expected /= actual ) then if ( present ( message )) then call test_failed ( error , message , more ) else call test_failed ( error , \"Integer value missmatch\" , more ) end if end if end subroutine check_int_i8 subroutine check_bool ( error , actual , expected , message , more ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> Found boolean value logical , intent ( in ) :: actual !> Expected boolean value logical , intent ( in ) :: expected !> A detailed message describing the error character ( len =* ), intent ( in ), optional :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more if ( expected . neqv . actual ) then if ( present ( message )) then call test_failed ( error , message , more ) else call test_failed ( error , \"Logical value missmatch\" , more ) end if end if end subroutine check_bool subroutine check_string ( error , actual , expected , message , more ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> Found boolean value character ( len =* ), intent ( in ) :: actual !> Expected boolean value character ( len =* ), intent ( in ) :: expected !> A detailed message describing the error character ( len =* ), intent ( in ), optional :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more if ( expected /= actual ) then if ( present ( message )) then call test_failed ( error , message , more ) else call test_failed ( error , \"Character value missmatch\" , more ) end if end if end subroutine check_string subroutine test_failed ( error , message , more ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> A detailed message describing the error character ( len =* ), intent ( in ) :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more allocate ( error ) error % stat = mctc_stat % fatal if ( present ( more )) then error % message = message // new_line ( 'a' ) // more else error % message = message end if end subroutine test_failed end module mctc_env_testing","tags":"","loc":"sourcefile/testing.f90.html"},{"title":"error.f90 – MCTC-library","text":"Contents Modules mctc_env_error Source Code error.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Central registry for error codes module mctc_env_error implicit none private public :: mctc_stat , error_type public :: fatal_error !> Possible error codes type :: enum_stat !> Successful run integer :: success = 0 !> Internal error: integer :: fatal = 1 end type enum_stat !> Actual enumerator for return states type ( enum_stat ), parameter :: mctc_stat = enum_stat () !> Error message type :: error_type !> Error code integer :: stat !> Payload of the error character ( len = :), allocatable :: message end type error_type contains !> A fatal error is encountered subroutine fatal_error ( error , message , stat ) !> Instance of the error type ( error_type ), allocatable , intent ( out ) :: error !> A detailed message describing the error and (optionally) offering advice character ( len =* ), intent ( in ), optional :: message !> Overwrite of the error code integer , intent ( in ), optional :: stat allocate ( error ) if ( present ( stat )) then error % stat = stat else error % stat = mctc_stat % fatal end if if ( present ( message )) then error % message = message else error % message = \"Fatal error\" end if end subroutine fatal_error end module mctc_env_error","tags":"","loc":"sourcefile/error.f90.html"},{"title":"write.f90 – MCTC-library","text":"Contents Modules mctc_io_write Source Code write.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_write use mctc_env_error , only : error_type , fatal_error use mctc_io_filetype , only : filetype , get_filetype use mctc_io_write_ctfile , only : write_molfile , write_sdf use mctc_io_write_gaussian , only : write_gaussian_external use mctc_io_write_genformat , only : write_genformat use mctc_io_write_pdb , only : write_pdb use mctc_io_write_turbomole , only : write_coord use mctc_io_write_vasp , only : write_vasp use mctc_io_write_xyz , only : write_xyz use mctc_io_structure , only : structure_type , new_structure implicit none private public :: write_structure interface write_structure module procedure :: write_structure_to_file module procedure :: write_structure_to_unit end interface write_structure contains subroutine write_structure_to_file ( self , file , error , format ) !> Instance of the molecular structure data class ( structure_type ), intent ( in ) :: self !> Name of the file to read character ( len =* ), intent ( in ) :: file !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> File type format hint integer , intent ( in ), optional :: format integer :: unit , ftype , stat open ( file = file , newunit = unit , iostat = stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Cannot open '\" // file // \"'\" ) return end if if ( present ( format )) then ftype = format else ftype = get_filetype ( file ) end if ! Unknown file type is inacceptable in this situation, ! try to figure something at least something out if ( ftype == filetype % unknown ) then if ( any ( self % periodic )) then ftype = filetype % vasp else if ( allocated ( self % sdf )) then ftype = filetype % sdf else if ( allocated ( self % pdb )) then ftype = filetype % pdb else ftype = filetype % xyz end if end if call write_structure ( self , unit , ftype , error ) close ( unit ) end subroutine write_structure_to_file subroutine write_structure_to_unit ( self , unit , ftype , error ) !> Instance of the molecular structure data class ( structure_type ), intent ( in ) :: self !> File handle integer , intent ( in ) :: unit !> File type to read integer , intent ( in ) :: ftype !> Error handling type ( error_type ), allocatable , intent ( out ) :: error select case ( ftype ) case default call fatal_error ( error , \"Cannot write unknown file format\" ) case ( filetype % xyz ) call write_xyz ( self , unit ) case ( filetype % molfile ) call write_molfile ( self , unit ) case ( filetype % pdb ) call write_pdb ( self , unit ) case ( filetype % gen ) call write_genformat ( self , unit ) case ( filetype % sdf ) call write_sdf ( self , unit ) case ( filetype % vasp ) call write_vasp ( self , unit ) case ( filetype % tmol ) call write_coord ( self , unit ) case ( filetype % gaussian ) call write_gaussian_external ( self , unit ) end select end subroutine write_structure_to_unit end module mctc_io_write","tags":"","loc":"sourcefile/write.f90.html"},{"title":"resize.f90 – MCTC-library","text":"Contents Modules mctc_io_resize Source Code resize.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Reallocation implementation for resizing arrays module mctc_io_resize use mctc_env_accuracy , only : wp implicit none private public :: resize !> Overloaded resize interface interface resize module procedure :: resize_char module procedure :: resize_int module procedure :: resize_real module procedure :: resize_real_2d end interface resize !> Initial size for dynamic sized arrays integer , parameter :: initial_size = 64 contains !> Reallocate list of integers pure subroutine resize_int ( var , n ) !> Instance of the array to be resized integer , allocatable , intent ( inout ) :: var (:) !> Dimension of the final array size integer , intent ( in ), optional :: n integer , allocatable :: tmp (:) integer :: this_size , new_size if ( allocated ( var )) then this_size = size ( var , 1 ) call move_alloc ( var , tmp ) else this_size = initial_size end if if ( present ( n )) then new_size = n else new_size = this_size + this_size / 2 + 1 end if allocate ( var ( new_size )) if ( allocated ( tmp )) then this_size = min ( size ( tmp , 1 ), size ( var , 1 )) var (: this_size ) = tmp (: this_size ) deallocate ( tmp ) end if end subroutine resize_int !> Reallocate list of characters pure subroutine resize_char ( var , n ) !> Instance of the array to be resized character ( len =* ), allocatable , intent ( inout ) :: var (:) !> Dimension of the final array size integer , intent ( in ), optional :: n character ( len = :), allocatable :: tmp (:) integer :: this_size , new_size if ( allocated ( var )) then this_size = size ( var , 1 ) call move_alloc ( var , tmp ) else this_size = initial_size end if if ( present ( n )) then new_size = n else new_size = this_size + this_size / 2 + 1 end if allocate ( var ( new_size )) if ( allocated ( tmp )) then this_size = min ( size ( tmp , 1 ), size ( var , 1 )) var (: this_size ) = tmp (: this_size ) deallocate ( tmp ) end if end subroutine resize_char !> Reallocate list of reals pure subroutine resize_real ( var , n ) !> Instance of the array to be resized real ( wp ), allocatable , intent ( inout ) :: var (:) !> Dimension of the final array size integer , intent ( in ), optional :: n real ( wp ), allocatable :: tmp (:) integer :: this_size , new_size if ( allocated ( var )) then this_size = size ( var , 1 ) call move_alloc ( var , tmp ) else this_size = initial_size end if if ( present ( n )) then new_size = n else new_size = this_size + this_size / 2 + 1 end if allocate ( var ( new_size )) if ( allocated ( tmp )) then this_size = min ( size ( tmp , 1 ), size ( var , 1 )) var (: this_size ) = tmp (: this_size ) deallocate ( tmp ) end if end subroutine resize_real !> Reallocate list of reals pure subroutine resize_real_2d ( var , n ) !> Instance of the array to be resized real ( wp ), allocatable , intent ( inout ) :: var (:,:) !> Dimension of the final array size integer , intent ( in ), optional :: n real ( wp ), allocatable :: tmp (:,:) integer :: order , this_size , new_size if ( allocated ( var )) then order = size ( var , 1 ) this_size = size ( var , 2 ) call move_alloc ( var , tmp ) else order = 3 this_size = initial_size end if if ( present ( n )) then new_size = n else new_size = this_size + this_size / 2 + 1 end if allocate ( var ( order , new_size )) if ( allocated ( tmp )) then this_size = min ( size ( tmp , 2 ), size ( var , 2 )) var (:, : this_size ) = tmp (:, : this_size ) deallocate ( tmp ) end if end subroutine resize_real_2d end module mctc_io_resize","tags":"","loc":"sourcefile/resize.f90.html"},{"title":"constants.f90 – MCTC-library","text":"Contents Modules mctc_io_constants Source Code constants.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Numerical constants module mctc_io_constants use mctc_env_accuracy , only : wp implicit none private public :: pi , codata !> Ratio between a circles diameter and its circumfence real ( wp ), parameter :: pi = 3.1415926535897932384626433832795029_wp !> Natural constants defining the SI unit base type :: enum_codata !> Planck's constant real ( wp ) :: h = 6.6260715e-34_wp ! J·s = kg·m²·s⁻¹ !> Speed of light in vacuum real ( wp ) :: c = 29979245 8.0_wp ! m·s⁻¹ !> Boltzmann's constant real ( wp ) :: kb = 1.380649e-23_wp ! J·K⁻¹ = kg·m²·s⁻²·K⁻¹ !> Avogadro's number real ( wp ) :: NA = 6.02214076e23_wp ! mol⁻¹ !> Elementary charge real ( wp ) :: e = 1.602176634e-19_wp ! C !> fine structure constant (CODATA2018) real ( wp ) :: alpha = 1.0_wp / 13 7.035999046_wp ! dimensionless !> electron rest mass real ( wp ) :: me = 9.10938356e-31_wp ! kg end type enum_codata !> Actual collection of natural constants type ( enum_codata ), parameter :: codata = enum_codata () end module mctc_io_constants","tags":"","loc":"sourcefile/constants.f90.html"},{"title":"math.f90 – MCTC-library","text":"Contents Modules mctc_io_math Source Code math.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Simple algebraic functions module mctc_io_math use mctc_env_accuracy , only : wp use mctc_io_constants , only : pi implicit none private public :: matdet_3x3 , matinv_3x3 , crossprod , eigval_3x3 , eigvec_3x3 real ( wp ), parameter :: twothirdpi = 2.0_wp * pi / 3.0_wp contains !> Performs a direct calculation of the inverse of a 3×3 matrix. ! !  reference: http://fortranwiki.org/fortran/show/Matrix+inversion pure function matinv_3x3 ( a ) result ( b ) !> Matrix real ( wp ), intent ( in ) :: a ( 3 , 3 ) !> Inverse matrix real ( wp ) :: b ( 3 , 3 ) real ( wp ) :: detinv ! Calculate the inverse determinant of the matrix detinv = 1.0_wp / matdet_3x3 ( a ) ! Calculate the inverse of the matrix b ( 1 , 1 ) = + detinv * ( a ( 2 , 2 ) * a ( 3 , 3 ) - a ( 2 , 3 ) * a ( 3 , 2 )) b ( 2 , 1 ) = - detinv * ( a ( 2 , 1 ) * a ( 3 , 3 ) - a ( 2 , 3 ) * a ( 3 , 1 )) b ( 3 , 1 ) = + detinv * ( a ( 2 , 1 ) * a ( 3 , 2 ) - a ( 2 , 2 ) * a ( 3 , 1 )) b ( 1 , 2 ) = - detinv * ( a ( 1 , 2 ) * a ( 3 , 3 ) - a ( 1 , 3 ) * a ( 3 , 2 )) b ( 2 , 2 ) = + detinv * ( a ( 1 , 1 ) * a ( 3 , 3 ) - a ( 1 , 3 ) * a ( 3 , 1 )) b ( 3 , 2 ) = - detinv * ( a ( 1 , 1 ) * a ( 3 , 2 ) - a ( 1 , 2 ) * a ( 3 , 1 )) b ( 1 , 3 ) = + detinv * ( a ( 1 , 2 ) * a ( 2 , 3 ) - a ( 1 , 3 ) * a ( 2 , 2 )) b ( 2 , 3 ) = - detinv * ( a ( 1 , 1 ) * a ( 2 , 3 ) - a ( 1 , 3 ) * a ( 2 , 1 )) b ( 3 , 3 ) = + detinv * ( a ( 1 , 1 ) * a ( 2 , 2 ) - a ( 1 , 2 ) * a ( 2 , 1 )) end function matinv_3x3 !> Determinat of 3×3 matrix pure function matdet_3x3 ( a ) result ( det ) !> Matrix real ( wp ), intent ( in ) :: a ( 3 , 3 ) !> Determinant real ( wp ) :: det det = a ( 1 , 1 ) * a ( 2 , 2 ) * a ( 3 , 3 ) & & - a ( 1 , 1 ) * a ( 2 , 3 ) * a ( 3 , 2 ) & & - a ( 1 , 2 ) * a ( 2 , 1 ) * a ( 3 , 3 ) & & + a ( 1 , 2 ) * a ( 2 , 3 ) * a ( 3 , 1 ) & & + a ( 1 , 3 ) * a ( 2 , 1 ) * a ( 3 , 2 ) & & - a ( 1 , 3 ) * a ( 2 , 2 ) * a ( 3 , 1 ) end function matdet_3x3 !> Implements the cross/vector product between two 3D vectors pure function crossprod ( a , b ) result ( c ) !> First vector real ( wp ), intent ( in ) :: a ( 3 ) !> Second vector real ( wp ), intent ( in ) :: b ( 3 ) !> Orthogonal vector real ( wp ) :: c ( 3 ) c ( 1 ) = a ( 2 ) * b ( 3 ) - b ( 2 ) * a ( 3 ) c ( 2 ) = a ( 3 ) * b ( 1 ) - b ( 3 ) * a ( 1 ) c ( 3 ) = a ( 1 ) * b ( 2 ) - b ( 1 ) * a ( 2 ) end function crossprod !> Calculates eigenvalues based on the trigonometric solution of A = pB + qI pure subroutine eigval_3x3 ( a , w ) !> The symmetric input matrix real ( wp ), intent ( in ) :: a ( 3 , 3 ) !> Contains eigenvalues on exit real ( wp ), intent ( out ) :: w ( 3 ) real ( wp ) :: q , p , r r = a ( 1 , 2 ) * a ( 1 , 2 ) + a ( 1 , 3 ) * a ( 1 , 3 ) + a ( 2 , 3 ) * a ( 2 , 3 ) q = ( a ( 1 , 1 ) + a ( 2 , 2 ) + a ( 3 , 3 )) / 3.0_wp w ( 1 ) = a ( 1 , 1 ) - q w ( 2 ) = a ( 2 , 2 ) - q w ( 3 ) = a ( 3 , 3 ) - q p = sqrt (( w ( 1 ) * w ( 1 ) + w ( 2 ) * w ( 2 ) + w ( 3 ) * w ( 3 ) + 2 * r ) / 6.0_wp ) r = ( w ( 1 ) * ( w ( 2 ) * w ( 3 ) - a ( 2 , 3 ) * a ( 2 , 3 )) & & - a ( 1 , 2 ) * ( a ( 1 , 2 ) * w ( 3 ) - a ( 2 , 3 ) * a ( 1 , 3 )) & & + a ( 1 , 3 ) * ( a ( 1 , 2 ) * a ( 2 , 3 ) - w ( 2 ) * a ( 1 , 3 ))) / ( p * p * p ) * 0.5_wp if ( r <= - 1.0_wp ) then r = 0.5_wp * twothirdpi else if ( r >= 1.0_wp ) then r = 0.0_wp else r = acos ( r ) / 3.0_wp end if w ( 3 ) = q + 2 * p * cos ( r ) w ( 1 ) = q + 2 * p * cos ( r + twothirdpi ) w ( 2 ) = 3 * q - w ( 1 ) - w ( 3 ) end subroutine eigval_3x3 !> Calculates eigenvector using an analytical method based on vector cross !  products. pure subroutine eigvec_3x3 ( a , w , q ) real ( wp ), intent ( inout ) :: a ( 3 , 3 ) real ( wp ), intent ( out ) :: w ( 3 ) real ( wp ), intent ( out ) :: q ( 3 , 3 ) real ( wp ), parameter :: eps = epsilon ( 1.0_wp ) real ( wp ) norm , n1 , n2 , n3 , precon integer :: i w ( 1 ) = max ( abs ( a ( 1 , 1 )), abs ( a ( 1 , 2 ))) w ( 2 ) = max ( abs ( a ( 1 , 3 )), abs ( a ( 2 , 2 ))) w ( 3 ) = max ( abs ( a ( 2 , 3 )), abs ( a ( 3 , 3 ))) precon = max ( w ( 1 ), max ( w ( 2 ), w ( 3 ))) ! null matrix if ( precon < eps ) then w ( 1 ) = 0.0_wp w ( 2 ) = 0.0_wp w ( 3 ) = 0.0_wp q ( 1 , 1 ) = 1.0_wp q ( 2 , 2 ) = 1.0_wp q ( 3 , 3 ) = 1.0_wp q ( 1 , 2 ) = 0.0_wp q ( 1 , 3 ) = 0.0_wp q ( 2 , 3 ) = 0.0_wp q ( 2 , 1 ) = 0.0_wp q ( 3 , 1 ) = 0.0_wp q ( 3 , 2 ) = 0.0_wp return end if norm = 1.0_wp / precon a ( 1 , 1 ) = a ( 1 , 1 ) * norm a ( 1 , 2 ) = a ( 1 , 2 ) * norm a ( 2 , 2 ) = a ( 2 , 2 ) * norm a ( 1 , 3 ) = a ( 1 , 3 ) * norm a ( 2 , 3 ) = a ( 2 , 3 ) * norm a ( 3 , 3 ) = a ( 3 , 3 ) * norm ! Calculate eigenvalues call eigval_3x3 ( a , w ) ! Compute first eigenvector a ( 1 , 1 ) = a ( 1 , 1 ) - w ( 1 ) a ( 2 , 2 ) = a ( 2 , 2 ) - w ( 1 ) a ( 3 , 3 ) = a ( 3 , 3 ) - w ( 1 ) q ( 1 , 1 ) = a ( 1 , 2 ) * a ( 2 , 3 ) - a ( 1 , 3 ) * a ( 2 , 2 ) q ( 2 , 1 ) = a ( 1 , 3 ) * a ( 1 , 2 ) - a ( 1 , 1 ) * a ( 2 , 3 ) q ( 3 , 1 ) = a ( 1 , 1 ) * a ( 2 , 2 ) - a ( 1 , 2 ) * a ( 1 , 2 ) q ( 1 , 2 ) = a ( 1 , 2 ) * a ( 3 , 3 ) - a ( 1 , 3 ) * a ( 2 , 3 ) q ( 2 , 2 ) = a ( 1 , 3 ) * a ( 1 , 3 ) - a ( 1 , 1 ) * a ( 3 , 3 ) q ( 3 , 2 ) = a ( 1 , 1 ) * a ( 2 , 3 ) - a ( 1 , 2 ) * a ( 1 , 3 ) q ( 1 , 3 ) = a ( 2 , 2 ) * a ( 3 , 3 ) - a ( 2 , 3 ) * a ( 2 , 3 ) q ( 2 , 3 ) = a ( 2 , 3 ) * a ( 1 , 3 ) - a ( 1 , 2 ) * a ( 3 , 3 ) q ( 3 , 3 ) = a ( 1 , 2 ) * a ( 2 , 3 ) - a ( 2 , 2 ) * a ( 1 , 3 ) n1 = q ( 1 , 1 ) * q ( 1 , 1 ) + q ( 2 , 1 ) * q ( 2 , 1 ) + q ( 3 , 1 ) * q ( 3 , 1 ) n2 = q ( 1 , 2 ) * q ( 1 , 2 ) + q ( 2 , 2 ) * q ( 2 , 2 ) + q ( 3 , 2 ) * q ( 3 , 2 ) n3 = q ( 1 , 3 ) * q ( 1 , 3 ) + q ( 2 , 3 ) * q ( 2 , 3 ) + q ( 3 , 3 ) * q ( 3 , 3 ) norm = n1 i = 1 if ( n2 > norm ) then i = 2 norm = n1 end if if ( n3 > norm ) then i = 3 end if if ( i == 1 ) then norm = sqrt ( 1.0_wp / n1 ) q ( 1 , 1 ) = q ( 1 , 1 ) * norm q ( 2 , 1 ) = q ( 2 , 1 ) * norm q ( 3 , 1 ) = q ( 3 , 1 ) * norm else if ( i == 2 ) then norm = sqrt ( 1.0_wp / n2 ) q ( 1 , 1 ) = q ( 1 , 2 ) * norm q ( 2 , 1 ) = q ( 2 , 2 ) * norm q ( 3 , 1 ) = q ( 3 , 2 ) * norm else norm = sqrt ( 1.0_wp / n3 ) q ( 1 , 1 ) = q ( 1 , 3 ) * norm q ( 2 , 1 ) = q ( 2 , 3 ) * norm q ( 3 , 1 ) = q ( 3 , 3 ) * norm end if ! Robustly compute a right-hand orthonormal set (ev1, u, v) if ( abs ( q ( 1 , 1 )) > abs ( q ( 2 , 1 ))) then norm = sqrt ( 1.0_wp / ( q ( 1 , 1 ) * q ( 1 , 1 ) + q ( 3 , 1 ) * q ( 3 , 1 ))) q ( 1 , 2 ) = - q ( 3 , 1 ) * norm q ( 2 , 2 ) = 0.0_wp q ( 3 , 2 ) = + q ( 1 , 1 ) * norm else norm = sqrt ( 1.0_wp / ( q ( 2 , 1 ) * q ( 2 , 1 ) + q ( 3 , 1 ) * q ( 3 , 1 ))) q ( 1 , 2 ) = 0.0_wp q ( 2 , 2 ) = + q ( 3 , 1 ) * norm q ( 3 , 2 ) = - q ( 2 , 1 ) * norm end if q ( 1 , 3 ) = q ( 2 , 1 ) * q ( 3 , 2 ) - q ( 3 , 1 ) * q ( 2 , 2 ) q ( 2 , 3 ) = q ( 3 , 1 ) * q ( 1 , 2 ) - q ( 1 , 1 ) * q ( 3 , 2 ) q ( 3 , 3 ) = q ( 1 , 1 ) * q ( 2 , 2 ) - q ( 2 , 1 ) * q ( 1 , 2 ) ! Reset A a ( 1 , 1 ) = a ( 1 , 1 ) + w ( 1 ) a ( 2 , 2 ) = a ( 2 , 2 ) + w ( 1 ) a ( 3 , 3 ) = a ( 3 , 3 ) + w ( 1 ) ! A*U n1 = a ( 1 , 1 ) * q ( 1 , 2 ) + a ( 1 , 2 ) * q ( 2 , 2 ) + a ( 1 , 3 ) * q ( 3 , 2 ) n2 = a ( 1 , 2 ) * q ( 1 , 2 ) + a ( 2 , 2 ) * q ( 2 , 2 ) + a ( 2 , 3 ) * q ( 3 , 2 ) n3 = a ( 1 , 3 ) * q ( 1 , 2 ) + a ( 2 , 3 ) * q ( 2 , 2 ) + a ( 3 , 3 ) * q ( 3 , 2 ) ! A*V, note out of order computation a ( 3 , 3 ) = a ( 1 , 3 ) * q ( 1 , 3 ) + a ( 2 , 3 ) * q ( 2 , 3 ) + a ( 3 , 3 ) * q ( 3 , 3 ) a ( 1 , 3 ) = a ( 1 , 1 ) * q ( 1 , 3 ) + a ( 1 , 2 ) * q ( 2 , 3 ) + a ( 1 , 3 ) * q ( 3 , 3 ) a ( 2 , 3 ) = a ( 1 , 2 ) * q ( 1 , 3 ) + a ( 2 , 2 ) * q ( 2 , 3 ) + a ( 2 , 3 ) * q ( 3 , 3 ) ! UT*(A*U) - l2*E n1 = q ( 1 , 2 ) * n1 + q ( 2 , 2 ) * n2 + q ( 3 , 2 ) * n3 - w ( 2 ) ! UT*(A*V) n2 = q ( 1 , 2 ) * a ( 1 , 3 ) + q ( 2 , 2 ) * a ( 2 , 3 ) + q ( 3 , 2 ) * a ( 3 , 3 ) ! VT*(A*V) - l2*E n3 = q ( 1 , 3 ) * a ( 1 , 3 ) + q ( 2 , 3 ) * a ( 2 , 3 ) + q ( 3 , 3 ) * a ( 3 , 3 ) - w ( 2 ) if ( abs ( n1 ) >= abs ( n3 )) then norm = max ( abs ( n1 ), abs ( n2 )) if ( norm > eps ) then if ( abs ( n1 ) >= abs ( n2 )) then n2 = n2 / n1 n1 = sqrt ( 1.0_wp / ( 1.0_wp + n2 * n2 )) n2 = n2 * n1 else n1 = n1 / n2 n2 = sqrt ( 1.0_wp / ( 1.0_wp + n1 * n1 )) n1 = n1 * n2 end if q ( 1 , 2 ) = n2 * q ( 1 , 2 ) - n1 * q ( 1 , 3 ) q ( 2 , 2 ) = n2 * q ( 2 , 2 ) - n1 * q ( 2 , 3 ) q ( 3 , 2 ) = n2 * q ( 3 , 2 ) - n1 * q ( 3 , 3 ) end if else norm = max ( abs ( n3 ), abs ( n2 )) if ( norm > eps ) then if ( abs ( n3 ) >= abs ( n2 )) then n2 = n2 / n3 n3 = sqrt ( 1.0_wp / ( 1.0_wp + n2 * n2 )) n2 = n2 * n3 else n3 = n3 / n2 n2 = sqrt ( 1.0_wp / ( 1.0_wp + n3 * n3 )) n3 = n3 * n2 end if q ( 1 , 2 ) = n3 * q ( 1 , 2 ) - n2 * q ( 1 , 3 ) q ( 2 , 2 ) = n3 * q ( 2 , 2 ) - n2 * q ( 2 , 3 ) q ( 3 , 2 ) = n3 * q ( 3 , 2 ) - n2 * q ( 3 , 3 ) end if end if ! Calculate third eigenvector from cross product q ( 1 , 3 ) = q ( 2 , 1 ) * q ( 3 , 2 ) - q ( 3 , 1 ) * q ( 2 , 2 ) q ( 2 , 3 ) = q ( 3 , 1 ) * q ( 1 , 2 ) - q ( 1 , 1 ) * q ( 3 , 2 ) q ( 3 , 3 ) = q ( 1 , 1 ) * q ( 2 , 2 ) - q ( 2 , 1 ) * q ( 1 , 2 ) w ( 1 ) = w ( 1 ) * precon w ( 2 ) = w ( 2 ) * precon w ( 3 ) = w ( 3 ) * precon end subroutine eigvec_3x3 end module mctc_io_math","tags":"","loc":"sourcefile/math.f90.html"},{"title":"filetype.f90 – MCTC-library","text":"Contents Modules mctc_io_filetype Source Code filetype.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> File type support module mctc_io_filetype implicit none private public :: filetype , get_filetype !> Possible file types type :: enum_filetype !> Unknown file type integer :: unknown = 0 !> xyz-format integer :: xyz = 1 !> Turbomole coordinate format integer :: tmol = 2 !> mol-format integer :: molfile = 3 !> Vasp coordinate input integer :: vasp = 4 !> Protein database format integer :: pdb = 5 !> Structure data format integer :: sdf = 6 !> GenFormat of DFTB+ integer :: gen = 7 !> Gaussian external format integer :: gaussian = 8 end type enum_filetype !> File type enumerator type ( enum_filetype ), parameter :: filetype = enum_filetype () contains elemental function get_filetype ( file ) result ( ftype ) !> Name of the file character ( len =* ), intent ( in ) :: file !> File type from extension integer :: ftype integer :: iext , isep ftype = filetype % unknown iext = index ( file , '.' , back = . true .) isep = scan ( file , '/\\', back=.true.) if (iext > isep .and. iext > 0) then select case(to_lower(file(iext+1:))) case(' coord ', ' tmol ') ftype = filetype%tmol case(' xyz ') ftype = filetype%xyz case(' mol ') ftype = filetype%molfile case(' sdf ') ftype = filetype%sdf case(' poscar ', ' contcar ', ' vasp ') ftype = filetype%vasp case(' pdb ') ftype = filetype%pdb case(' gen ') ftype = filetype%gen case(' ein ') ftype = filetype%gaussian end select if (ftype /= filetype%unknown) return else iext = len(file) + 1 end if if (iext > isep) then select case(to_lower(file(isep+1:iext-1))) case(' coord ') ftype = filetype%tmol case(' poscar ', ' contcar ') ftype = filetype%vasp end select end if end function get_filetype !> Convert input string to lowercase elemental function to_lower(str) result(lcstr) !> Input string character(len=*), intent(in) :: str !> Lowercase version of string character(len=len(str)):: lcstr integer :: ilen, iquote, i, iav, iqc integer, parameter :: offset = iachar(' A ') - iachar(' a ') ilen = len(str) iquote = 0 lcstr = str do i = 1, ilen iav = iachar(str(i:i)) if (iquote == 0 .and. (iav == 34 .or.iav == 39)) then iquote = 1 iqc = iav cycle end if if (iquote == 1 .and. iav==iqc) then iquote=0 cycle end if if (iquote == 1) cycle if (iav >= iachar(' A ') .and. iav <= iachar(' Z ' )) then lcstr ( i : i ) = achar ( iav - offset ) else lcstr ( i : i ) = str ( i : i ) end if end do end function to_lower end module mctc_io_filetype","tags":"","loc":"sourcefile/filetype.f90.html"},{"title":"utils.f90 – MCTC-library","text":"Contents Modules mctc_io_utils Source Code utils.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_utils implicit none private public :: getline contains subroutine getline ( unit , line , iostat , iomsg ) !> Formatted IO unit integer , intent ( in ) :: unit !> Line to read character ( len = :), allocatable , intent ( out ) :: line !> Status of operation integer , intent ( out ) :: iostat !> Error message character ( len = :), allocatable , optional :: iomsg integer , parameter :: bufsize = 512 character ( len = bufsize ) :: buffer character ( len = bufsize ) :: msg integer :: size integer :: stat allocate ( character ( len = 0 ) :: line ) do read ( unit , '(a)' , advance = 'no' , iostat = stat , iomsg = msg , size = size ) & & buffer if ( stat > 0 ) exit line = line // buffer (: size ) if ( stat < 0 ) then if ( is_iostat_eor ( stat )) then stat = 0 end if exit end if end do if ( stat /= 0 ) then if ( present ( iomsg )) iomsg = trim ( msg ) end if iostat = stat end subroutine getline end module mctc_io_utils","tags":"","loc":"sourcefile/utils.f90.html"},{"title":"read.f90 – MCTC-library","text":"Contents Modules mctc_io_read Source Code read.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_read use mctc_env_error , only : error_type , fatal_error use mctc_io_filetype , only : filetype , get_filetype use mctc_io_read_ctfile , only : read_molfile , read_sdf use mctc_io_read_gaussian , only : read_gaussian_external use mctc_io_read_genformat , only : read_genformat use mctc_io_read_pdb , only : read_pdb use mctc_io_read_turbomole , only : read_coord use mctc_io_read_vasp , only : read_vasp use mctc_io_read_xyz , only : read_xyz use mctc_io_structure , only : structure_type , new_structure implicit none private public :: read_structure public :: structure_reader , get_structure_reader interface read_structure module procedure :: read_structure_from_file module procedure :: read_structure_from_unit end interface read_structure abstract interface !> Read molecular structure data from formatted unit subroutine structure_reader ( self , unit , error ) import :: structure_type , error_type !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error end subroutine structure_reader end interface contains subroutine read_structure_from_file ( self , file , error , format ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> Name of the file to read character ( len =* ), intent ( in ) :: file !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> File type format hint integer , intent ( in ), optional :: format logical :: exist integer :: unit , stat , ftype inquire ( file = file , exist = exist ) if (. not . exist ) then call fatal_error ( error , \"File '\" // file // \"' cannot be found\" ) return end if open ( file = file , newunit = unit , status = 'old' , iostat = stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Cannot open '\" // file // \"'\" ) return end if if ( present ( format )) then ftype = format else ftype = get_filetype ( file ) end if call read_structure ( self , unit , ftype , error ) close ( unit ) end subroutine read_structure_from_file subroutine read_structure_from_unit ( self , unit , ftype , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> File type to read integer , intent ( in ) :: ftype !> Error handling type ( error_type ), allocatable , intent ( out ) :: error procedure ( structure_reader ), pointer :: reader call get_structure_reader ( reader , ftype ) if (. not . associated ( reader )) then call fatal_error ( error , \"Cannot read structure from unknown file format\" ) return end if call reader ( self , unit , error ) end subroutine read_structure_from_unit !> Retrieve reader for corresponding file type subroutine get_structure_reader ( reader , ftype ) !> Reader for the specified file type procedure ( structure_reader ), pointer , intent ( out ) :: reader !> File type to read integer , intent ( in ) :: ftype nullify ( reader ) select case ( ftype ) case ( filetype % xyz ) reader => read_xyz case ( filetype % molfile ) reader => read_molfile case ( filetype % pdb ) reader => read_pdb case ( filetype % gen ) reader => read_genformat case ( filetype % sdf ) reader => read_sdf case ( filetype % vasp ) reader => read_vasp case ( filetype % tmol ) reader => read_coord case ( filetype % gaussian ) reader => read_gaussian_external end select end subroutine get_structure_reader end module mctc_io_read","tags":"","loc":"sourcefile/read.f90.html"},{"title":"symbols.f90 – MCTC-library","text":"Contents Modules mctc_io_symbols Source Code symbols.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Handle conversion between element symbols and atomic numbers module mctc_io_symbols use mctc_io_resize , only : resize implicit none private public :: symbol_length public :: symbol_to_number , number_to_symbol , number_to_lcsymbol public :: to_number , to_symbol , to_lcsymbol public :: get_identity , collect_identical !> Get chemical identity interface get_identity module procedure :: get_identity_number module procedure :: get_identity_symbol end interface get_identity !> Maximum allowed length of element symbols integer , parameter :: symbol_length = 4 !> Periodic system of elements character ( len = 2 ), parameter :: pse ( 118 ) = [ & & 'H ' , 'He' , & & 'Li' , 'Be' , 'B ' , 'C ' , 'N ' , 'O ' , 'F ' , 'Ne' , & & 'Na' , 'Mg' , 'Al' , 'Si' , 'P ' , 'S ' , 'Cl' , 'Ar' , & & 'K ' , 'Ca' , & & 'Sc' , 'Ti' , 'V ' , 'Cr' , 'Mn' , 'Fe' , 'Co' , 'Ni' , 'Cu' , 'Zn' , & & 'Ga' , 'Ge' , 'As' , 'Se' , 'Br' , 'Kr' , & & 'Rb' , 'Sr' , & & 'Y ' , 'Zr' , 'Nb' , 'Mo' , 'Tc' , 'Ru' , 'Rh' , 'Pd' , 'Ag' , 'Cd' , & & 'In' , 'Sn' , 'Sb' , 'Te' , 'I ' , 'Xe' , & & 'Cs' , 'Ba' , & & 'La' , 'Ce' , 'Pr' , 'Nd' , 'Pm' , 'Sm' , 'Eu' , 'Gd' , 'Tb' , 'Dy' , 'Ho' , 'Er' , 'Tm' , 'Yb' , & & 'Lu' , 'Hf' , 'Ta' , 'W ' , 'Re' , 'Os' , 'Ir' , 'Pt' , 'Au' , 'Hg' , & & 'Tl' , 'Pb' , 'Bi' , 'Po' , 'At' , 'Rn' , & & 'Fr' , 'Ra' , & & 'Ac' , 'Th' , 'Pa' , 'U ' , 'Np' , 'Pu' , 'Am' , 'Cm' , 'Bk' , 'Cf' , 'Es' , 'Fm' , 'Md' , 'No' , & & 'Lr' , 'Rf' , 'Db' , 'Sg' , 'Bh' , 'Hs' , 'Mt' , 'Ds' , 'Rg' , 'Cn' , & & 'Nh' , 'Fl' , 'Mc' , 'Lv' , 'Ts' , 'Og' ] !> Lower case version of the periodic system of elements character ( len = 2 ), parameter :: lcpse ( 118 ) = [ & & 'h ' , 'he' , & & 'li' , 'be' , 'b ' , 'c ' , 'n ' , 'o ' , 'f ' , 'ne' , & & 'na' , 'mg' , 'al' , 'si' , 'p ' , 's ' , 'cl' , 'ar' , & & 'k ' , 'ca' , & & 'sc' , 'ti' , 'v ' , 'cr' , 'mn' , 'fe' , 'co' , 'ni' , 'cu' , 'zn' , & & 'ga' , 'ge' , 'as' , 'se' , 'br' , 'kr' , & & 'rb' , 'sr' , & & 'y ' , 'zr' , 'nb' , 'mo' , 'tc' , 'ru' , 'rh' , 'pd' , 'ag' , 'cd' , & & 'in' , 'sn' , 'sb' , 'te' , 'i ' , 'xe' , & & 'cs' , 'ba' , 'la' , & & 'ce' , 'pr' , 'nd' , 'pm' , 'sm' , 'eu' , 'gd' , 'tb' , 'dy' , 'ho' , 'er' , 'tm' , 'yb' , & & 'lu' , 'hf' , 'ta' , 'w ' , 're' , 'os' , 'ir' , 'pt' , 'au' , 'hg' , & & 'tl' , 'pb' , 'bi' , 'po' , 'at' , 'rn' , & & 'fr' , 'ra' , 'ac' , & & 'th' , 'pa' , 'u ' , 'np' , 'pu' , 'am' , 'cm' , 'bk' , 'cf' , 'es' , 'fm' , 'md' , 'no' , & & 'lr' , 'rf' , 'db' , 'sg' , 'bh' , 'hs' , 'mt' , 'ds' , 'rg' , 'cn' , & & 'nh' , 'fl' , 'mc' , 'lv' , 'ts' , 'og' ] !> ASCII offset between lowercase and uppercase letters integer , parameter :: offset = iachar ( 'a' ) - iachar ( 'A' ) contains !> Convert element symbol to atomic number elemental subroutine symbol_to_number ( number , symbol ) !> Element symbol character ( len =* ), intent ( in ) :: symbol !> Atomic number integer , intent ( out ) :: number character ( len = 2 ) :: lcsymbol integer :: i , j , k , l number = 0 lcsymbol = '  ' k = 0 do j = 1 , len_trim ( symbol ) if ( k > 2 ) exit l = iachar ( symbol ( j : j )) if ( k >= 1 . and . l == iachar ( ' ' )) exit if ( k >= 1 . and . l == 9 ) exit if ( l >= iachar ( 'A' ) . and . l <= iachar ( 'Z' )) l = l + offset if ( l >= iachar ( 'a' ) . and . l <= iachar ( 'z' )) then k = k + 1 if ( k > 2 ) exit lcsymbol ( k : k ) = achar ( l ) endif enddo do i = 1 , size ( lcpse ) if ( lcsymbol == lcpse ( i )) then number = i exit endif enddo if ( number == 0 ) then select case ( lcsymbol ) case ( 'd ' , 't ' ) number = 1 end select end if end subroutine symbol_to_number !> Convert atomic number to element symbol elemental subroutine number_to_symbol ( symbol , number ) !> Atomic number integer , intent ( in ) :: number !> Element symbol character ( len = 2 ), intent ( out ) :: symbol if ( number <= 0 . or . number > size ( pse )) then symbol = '--' else symbol = pse ( number ) endif end subroutine number_to_symbol !> Convert atomic number to element symbol elemental subroutine number_to_lcsymbol ( symbol , number ) !> Atomic number integer , intent ( in ) :: number !> Element symbol character ( len = 2 ), intent ( out ) :: symbol if ( number <= 0 . or . number > size ( lcpse )) then symbol = '--' else symbol = lcpse ( number ) endif end subroutine number_to_lcsymbol !> Convert element symbol to atomic number elemental function to_number ( symbol ) result ( number ) !> Element symbol character ( len =* ), intent ( in ) :: symbol !> Atomic number integer :: number call symbol_to_number ( number , symbol ) end function to_number !> Convert atomic number to element symbol elemental function to_symbol ( number ) result ( symbol ) !> Atomic number integer , intent ( in ) :: number !> Element symbol character ( len = 2 ) :: symbol call number_to_symbol ( symbol , number ) end function to_symbol !> Convert atomic number to element symbol elemental function to_lcsymbol ( number ) result ( symbol ) !> Atomic number integer , intent ( in ) :: number !> Element symbol character ( len = 2 ) :: symbol call number_to_lcsymbol ( symbol , number ) end function to_lcsymbol !> Get chemical identity from a list of atomic numbers pure subroutine get_identity_number ( nid , identity , number ) !> Number of unique species integer , intent ( out ) :: nid !> Ordinal numbers integer , intent ( in ) :: number (:) !> Chemical identity integer , intent ( out ) :: identity (:) integer , allocatable :: itmp (:) integer :: nat , iat , iid nat = size ( identity ) allocate ( itmp ( nat )) nid = 0 do iat = 1 , nat iid = find_number ( itmp (: nid ), number ( iat )) if ( iid == 0 ) then call append_number ( itmp , nid , number ( iat )) iid = nid end if identity ( iat ) = iid end do end subroutine get_identity_number !> Get chemical identity from a list of element symbols pure subroutine get_identity_symbol ( nid , identity , symbol ) !> Number of unique species integer , intent ( out ) :: nid !> Element symbols character ( len = symbol_length ), intent ( in ) :: symbol (:) !> Chemical identity integer , intent ( out ) :: identity (:) character ( len = symbol_length ), allocatable :: stmp (:) integer :: nat , iat , iid nat = size ( identity ) allocate ( stmp ( nat )) nid = 0 do iat = 1 , nat iid = find_symbol ( stmp (: nid ), symbol ( iat )) if ( iid == 0 ) then call append_symbol ( stmp , nid , symbol ( iat )) iid = nid end if identity ( iat ) = iid end do end subroutine get_identity_symbol !> Establish a mapping between unique atom types and species pure subroutine collect_identical ( identity , mapping ) !> Chemical identity integer , intent ( in ) :: identity (:) !> Mapping from unique atoms integer , intent ( out ) :: mapping (:) integer :: iid , iat do iid = 1 , size ( mapping ) do iat = 1 , size ( identity ) if ( identity ( iat ) == iid ) then mapping ( iid ) = iat exit end if end do end do end subroutine collect_identical !> Find element symbol in an unordered list, all entries are required to be unique pure function find_symbol ( list , symbol ) result ( position ) !> List of element symbols character ( len =* ), intent ( in ) :: list (:) !> Element symbol character ( len =* ), intent ( in ) :: symbol !> Position of the symbol in list if found, otherwise zero integer :: position integer :: isym position = 0 do isym = 1 , size ( list ) if ( symbol == list ( isym )) then position = isym exit end if end do end function find_symbol !> Find atomic number in an unordered list, all entries are required to be unique pure function find_number ( list , number ) result ( position ) !> List of atomic numbers integer , intent ( in ) :: list (:) !> Atomic number integer , intent ( in ) :: number !> Position of the number in list if found, otherwise zero integer :: position integer :: inum position = 0 do inum = 1 , size ( list ) if ( number == list ( inum )) then position = inum exit end if end do end function find_number !> Append an element symbol to an unsorted list, to ensure no dublicates search !> for the element symbol first pure subroutine append_symbol ( list , nlist , symbol ) !> List of element symbols character ( len =* ), allocatable , intent ( inout ) :: list (:) !> Current occupied size of list integer , intent ( inout ) :: nlist !> Elements symbol character ( len =* ), intent ( in ) :: symbol if ( nlist >= size ( list )) then call resize ( list ) end if nlist = nlist + 1 list ( nlist ) = symbol end subroutine append_symbol !> Append an atomic number to an unsorted list, to ensure no dublicates search !> for the atomic number first pure subroutine append_number ( list , nlist , number ) !> List of atomic number integer , allocatable , intent ( inout ) :: list (:) !> Current occupied size of list integer , intent ( inout ) :: nlist !> Atomic number integer , intent ( in ) :: number if ( nlist >= size ( list )) then call resize ( list ) end if nlist = nlist + 1 list ( nlist ) = number end subroutine append_number end module mctc_io_symbols","tags":"","loc":"sourcefile/symbols.f90.html"},{"title":"structure.f90 – MCTC-library","text":"Contents Modules mctc_io_structure Source Code structure.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Basic structure representation of the system of interest module mctc_io_structure use mctc_env_accuracy , only : wp use mctc_io_symbols , only : to_number , to_symbol , symbol_length , get_identity , & & collect_identical use mctc_io_structure_info , only : structure_info , pdb_data , sdf_data implicit none private public :: structure_type , new_structure , new !> Structure representation type :: structure_type !> Number of atoms integer :: nat = 0 !> Number of unique species integer :: nid = 0 !> Species identifier integer , allocatable :: id (:) !> Atomic number for each species integer , allocatable :: num (:) !> Element symbol for each species character ( len = symbol_length ), allocatable :: sym (:) !> Cartesian coordinates, in Bohr real ( wp ), allocatable :: xyz (:, :) !> Number of unpaired electrons integer :: uhf = 0 !> Total charge real ( wp ) :: charge = 0.0_wp !> Lattice parameters real ( wp ), allocatable :: lattice (:, :) !> Periodic directions logical , allocatable :: periodic (:) !> Vendor specific structure annotations type ( structure_info ) :: info = structure_info () !> SDF atomic data annotations type ( sdf_data ), allocatable :: sdf (:) !> PDB atomic data annotations type ( pdb_data ), allocatable :: pdb (:) end type structure_type interface new module procedure :: new_structure module procedure :: new_structure_num module procedure :: new_structure_sym end interface contains !> Constructor for structure representations subroutine new_structure ( self , num , sym , xyz , charge , uhf , lattice , periodic , info ) !> Instance of the structure representation type ( structure_type ), intent ( out ) :: self !> Atomic numbers integer , intent ( in ) :: num (:) !> Element symbols character ( len =* ), intent ( in ) :: sym (:) !> Cartesian coordinates real ( wp ), intent ( in ) :: xyz (:, :) !> Total charge real ( wp ), intent ( in ), optional :: charge !> Number of unpaired electrons integer , intent ( in ), optional :: uhf !> Lattice parameters real ( wp ), intent ( in ), optional :: lattice (:, :) !> Periodic directions logical , intent ( in ), optional :: periodic (:) !> Vendor specific structure information type ( structure_info ), intent ( in ), optional :: info integer :: ndim , iid integer , allocatable :: map (:) ndim = min ( size ( num , 1 ), size ( xyz , 2 ), size ( sym , 1 )) self % nat = ndim allocate ( self % id ( ndim )) allocate ( self % xyz ( 3 , ndim )) if ( present ( lattice )) then self % lattice = lattice end if if ( present ( periodic )) then self % periodic = periodic else if ( present ( lattice )) then allocate ( self % periodic ( 3 )) self % periodic (:) = . true . else allocate ( self % periodic ( 1 )) self % periodic (:) = . false . end if end if call get_identity ( self % nid , self % id , sym ) allocate ( map ( self % nid )) call collect_identical ( self % id , map ) allocate ( self % num ( self % nid )) allocate ( self % sym ( self % nid )) do iid = 1 , self % nid self % num ( iid ) = num ( map ( iid )) self % sym ( iid ) = sym ( map ( iid )) end do self % xyz (:, :) = xyz (:, : ndim ) if ( present ( charge )) then self % charge = charge else self % charge = 0.0_wp end if if ( present ( uhf )) then self % uhf = uhf else self % uhf = 0 end if if ( present ( info )) then self % info = info else self % info = structure_info () end if end subroutine new_structure !> Simplified constructor for structure representations subroutine new_structure_num ( self , num , xyz , charge , uhf , lattice , periodic , info ) !> Instance of the structure representation type ( structure_type ), intent ( out ) :: self !> Atomic numbers integer , intent ( in ) :: num (:) !> Cartesian coordinates real ( wp ), intent ( in ) :: xyz (:, :) !> Total charge real ( wp ), intent ( in ), optional :: charge !> Number of unpaired electrons integer , intent ( in ), optional :: uhf !> Lattice parameters real ( wp ), intent ( in ), optional :: lattice (:, :) !> Periodic directions logical , intent ( in ), optional :: periodic (:) !> Vendor specific structure information type ( structure_info ), intent ( in ), optional :: info integer :: ndim , iat character ( len = symbol_length ), allocatable :: sym (:) ndim = min ( size ( num , 1 ), size ( xyz , 2 )) allocate ( sym ( ndim )) do iat = 1 , ndim sym ( iat ) = to_symbol ( num ( iat )) end do call new_structure ( self , num , sym , xyz , charge , uhf , lattice , periodic , info ) end subroutine new_structure_num !> Simplified constructor for structure representations subroutine new_structure_sym ( self , sym , xyz , charge , uhf , lattice , periodic , info ) !> Instance of the structure representation type ( structure_type ), intent ( out ) :: self !> Element symbols character ( len =* ), intent ( in ) :: sym (:) !> Cartesian coordinates real ( wp ), intent ( in ) :: xyz (:, :) !> Total charge real ( wp ), intent ( in ), optional :: charge !> Number of unpaired electrons integer , intent ( in ), optional :: uhf !> Lattice parameters real ( wp ), intent ( in ), optional :: lattice (:, :) !> Periodic directions logical , intent ( in ), optional :: periodic (:) !> Vendor specific structure information type ( structure_info ), intent ( in ), optional :: info integer :: ndim , iat integer , allocatable :: num (:) ndim = min ( size ( sym , 1 ), size ( xyz , 2 )) allocate ( num ( ndim )) do iat = 1 , ndim num ( iat ) = to_number ( sym ( iat )) end do call new_structure ( self , num , sym , xyz , charge , uhf , lattice , periodic , info ) end subroutine new_structure_sym end module mctc_io_structure","tags":"","loc":"sourcefile/structure.f90.html"},{"title":"convert.f90 – MCTC-library","text":"Contents Modules mctc_io_convert Source Code convert.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Conversion factors module mctc_io_convert use mctc_env_accuracy , only : wp use mctc_io_constants , only : pi , codata implicit none private !> Reducted Planck's constant real ( wp ), parameter :: hbar = codata % h / ( 2.0_wp * pi ) ! J·s = kg·m²·s⁻¹ !> Bohr radius real ( wp ), parameter :: bohr = hbar / ( codata % me * codata % c * codata % alpha ) ! m !> Hartree energy real ( wp ), parameter :: hartree = codata % me * codata % c ** 2 * codata % alpha ** 2 ! J = kg·m²·s⁻² !> Conversion factor from bohr to Ångström real ( wp ), public , parameter :: autoaa = bohr * 1e10_wp !> Conversion factor from Ångström to bohr real ( wp ), public , parameter :: aatoau = 1.0_wp / autoaa !> Conversion factor from hartree to electron volts real ( wp ), public , parameter :: autoeV = hartree / codata % e !> Conversion factor from electron volts to hartree real ( wp ), public , parameter :: evtoau = 1.0_wp / autoev !> Coversion factor between calorine and joule real ( wp ), public , parameter :: caltoj = 4.184_wp !> Coversion factor between joule and calorine real ( wp ), public , parameter :: jtocal = 1.0_wp / caltoj !> Conversion from hartree to kJ/mol real ( wp ), public , parameter :: autokj = hartree * codata % na * 1e-3_wp !> Conversion from kJ/mol to hartree real ( wp ), public , parameter :: kjtoau = 1.0_wp / autokj !> Conversion from hartree to kcal/mol real ( wp ), public , parameter :: autokcal = autokJ * Jtocal !> Conversion from kcal/mol to hartree real ( wp ), public , parameter :: kcaltoau = 1.0_wp / autokcal !> Conversion from hartree to reciprocal centimeters real ( wp ), public , parameter :: autorcm = hartree / ( codata % h * codata % c ) * 1e-2_wp !> Conversion from reciprocal centimeters to hartree real ( wp ), public , parameter :: rcmtoau = 1.0_wp / autorcm !> Conversion from hartree to nanometers (wavelength) real ( wp ), public , parameter :: autonm = codata % h * codata % c / hartree * 1e+9_wp !> Conversion from nanometers (wavelength) to hartree real ( wp ), public , parameter :: nmtoau = 1.0_wp / autonm !> Conversion from electron mass (a.u.) to kg real ( wp ), public , parameter :: autokg = codata % me !> Conversion from kg to electron mass (a.u.) real ( wp ), public , parameter :: kgtoau = 1.0_wp / autokg !> Molecular mass per mole (g/mol) to electron mass (a.u.) real ( wp ), public , parameter :: autogmol = codata % me * codata % na * 1e+3_wp !> Electron mass (a.u.) to molecular mass per mole (g/mol) real ( wp ), public , parameter :: gmoltoau = 1.0_wp / autogmol !> Molecular mass per mole (g/mol) to kg real ( wp ), public , parameter :: gmoltokg = gmoltoau * autokg !> kg to molecular mass per mole (g/mol) real ( wp ), public , parameter :: kgtogmol = 1.0_wp / gmoltokg !> Coulomb to atomic charge units real ( wp ), public , parameter :: autoc = codata % e !> Atomic charge units to Coulomb real ( wp ), public , parameter :: ctoau = 1.0_wp / autoc end module mctc_io_convert","tags":"","loc":"sourcefile/convert.f90.html"},{"title":"gaussian.f90 – MCTC-library","text":"Contents Modules mctc_io_write_gaussian Source Code gaussian.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_write_gaussian use mctc_env_accuracy , only : wp use mctc_io_structure , only : structure_type implicit none private public :: write_gaussian_external contains subroutine write_gaussian_external ( mol , unit ) type ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit integer :: iat write ( unit , '(4i10)' ) mol % nat , 1 , nint ( mol % charge ), mol % uhf do iat = 1 , mol % nat write ( unit , '(i10,4f20.12)' ) mol % num ( mol % id ( iat )), mol % xyz (:, iat ), 0.0_wp end do end subroutine write_gaussian_external end module mctc_io_write_gaussian","tags":"","loc":"sourcefile/gaussian.f90.html"},{"title":"pdb.f90 – MCTC-library","text":"Contents Modules mctc_io_write_pdb Source Code pdb.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_write_pdb use mctc_env_accuracy , only : wp use mctc_io_convert , only : autoaa use mctc_io_structure , only : structure_type implicit none private public :: write_pdb contains subroutine write_pdb ( mol , unit , number ) type ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit integer , intent ( in ), optional :: number character ( len = 6 ) :: w1 character ( len = 4 ) :: sym character ( len = 2 ) :: a_charge character ( len = 1 ) :: last_chain logical :: last_het integer :: offset , iat , jat real ( wp ) :: xyz ( 3 ) character ( len =* ), parameter :: pdb_format = & & '(a6,i5,1x,a4,a1,a3,1x,a1,i4,a1,3x,3f8.3,2f6.2,6x,a4,a2,a2)' if ( present ( number )) write ( unit , '(\"MODEL \",4x,i4)' ) number if ( allocated ( mol % pdb )) then offset = 0 last_chain = mol % pdb ( 1 )% chains last_het = mol % pdb ( 1 )% het do iat = 1 , mol % nat ! handle the terminator if ( mol % pdb ( iat )% het . neqv . last_het ) then write ( unit , '(\"TER   \",i5,6x,a3,1x,a1,i4)' ) iat + offset , & & mol % pdb ( iat - 1 )% residue , last_chain , mol % pdb ( iat )% residue_number last_het = . not . last_het offset = offset + 1 else if ( mol % pdb ( iat )% chains /= last_chain ) then write ( unit , '(\"TER   \",i5,6x,a3,1x,a1,i4)' ) iat + offset , & & mol % pdb ( iat - 1 )% residue , last_chain , mol % pdb ( iat )% residue_number offset = offset + 1 endif jat = iat + offset if ( mol % pdb ( iat )% het ) then w1 = \"HETATM\" else w1 = \"ATOM  \" endif sym = adjustr ( mol % sym ( mol % id ( iat ))( 1 : 2 )) xyz = mol % xyz (:, iat ) * autoaa if ( mol % pdb ( iat )% charge < 0 ) then write ( a_charge , '(i1,\"-\")' ) abs ( mol % pdb ( iat )% charge ) else if ( mol % pdb ( iat )% charge > 0 ) then write ( a_charge , '(i1,\"+\")' ) abs ( mol % pdb ( iat )% charge ) else a_charge = '  ' endif write ( unit , pdb_format ) & & w1 , jat , mol % pdb ( iat )% name , mol % pdb ( iat )% loc , & & mol % pdb ( iat )% residue , mol % pdb ( iat )% chains , mol % pdb ( iat )% residue_number , & & mol % pdb ( iat )% code , xyz , 1.0_wp , 0.0_wp , mol % pdb ( iat )% segid , & & sym , a_charge enddo else do iat = 1 , mol % nat w1 = \"HETATM\" sym = adjustr ( mol % sym ( mol % id ( iat ))( 1 : 2 )) xyz = mol % xyz (:, iat ) * autoaa a_charge = '  ' write ( unit , pdb_format ) & & w1 , iat , sym , \" \" , & & \"UNK\" , \"A\" , 1 , \" \" , xyz , 1.0_wp , 0.0_wp , \"    \" , & & sym , \"  \" enddo end if if ( present ( number )) then write ( unit , '(\"ENDMDL\")' ) else write ( unit , '(\"END\")' ) endif end subroutine write_pdb end module mctc_io_write_pdb","tags":"","loc":"sourcefile/pdb.f90.html"},{"title":"xyz.f90 – MCTC-library","text":"Contents Modules mctc_io_write_xyz Source Code xyz.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_write_xyz use mctc_io_convert , only : autoaa use mctc_io_structure , only : structure_type implicit none private public :: write_xyz contains subroutine write_xyz ( mol , unit , comment_line ) class ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit character ( len =* ), intent ( in ), optional :: comment_line integer :: iat write ( unit , '(i0)' ) mol % nat if ( present ( comment_line )) then write ( unit , '(a)' ) comment_line else write ( unit , '(a)' ) end if do iat = 1 , mol % nat write ( unit , '(a4, 1x, 3es24.14)' ) & & mol % sym ( mol % id ( iat )), mol % xyz (:, iat ) * autoaa enddo end subroutine write_xyz end module mctc_io_write_xyz","tags":"","loc":"sourcefile/xyz.f90.html"},{"title":"vasp.f90 – MCTC-library","text":"Contents Modules mctc_io_write_vasp Source Code vasp.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_write_vasp use mctc_env_accuracy , only : wp use mctc_io_convert , only : autoaa use mctc_io_math , only : matinv_3x3 use mctc_io_structure , only : structure_type implicit none private public :: write_vasp contains subroutine write_vasp ( mol , unit , comment_line ) class ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit character ( len =* ), intent ( in ), optional :: comment_line integer :: i , j , izp integer , allocatable :: kinds (:), species (:) real ( wp ), allocatable :: inv_lat (:, :) real ( wp ), allocatable :: abc (:, :) allocate ( species ( mol % nat )) allocate ( kinds ( mol % nat ), source = 1 ) j = 0 izp = 0 do i = 1 , mol % nat if ( izp . eq . mol % id ( i )) then kinds ( j ) = kinds ( j ) + 1 else j = j + 1 izp = mol % id ( i ) species ( j ) = mol % id ( i ) endif enddo ! use vasp 5.x format if ( present ( comment_line )) then write ( unit , '(a)' ) comment_line else do i = 1 , j write ( unit , '(1x, a)' , advance = 'no' ) mol % sym ( species ( i )) enddo write ( unit , '(a)' ) end if ! scaling factor for lattice parameters is always one write ( unit , '(f20.14)' ) mol % info % scale ! write the lattice parameters if ( allocated ( mol % lattice )) then do i = 1 , 3 write ( unit , '(3f20.14)' ) mol % lattice (:, i ) * autoaa / mol % info % scale enddo else write ( unit , '(3f20.14)' ) spread ( 0.0_wp , 1 , 9 ) end if if ( present ( comment_line )) then do i = 1 , j write ( unit , '(1x, a)' , advance = 'no' ) mol % sym ( species ( i )) enddo write ( unit , '(a)' ) end if ! write the count of the consequtive atom types do i = 1 , j write ( unit , '(1x, i0)' , advance = 'no' ) kinds ( i ) enddo write ( unit , '(a)' ) deallocate ( kinds , species ) if ( mol % info % selective ) write ( unit , '(\"Selective\")' ) ! we write cartesian coordinates if (. not . allocated ( mol % lattice ) . or . mol % info % cartesian ) then write ( unit , '(\"Cartesian\")' ) ! now write the cartesian coordinates do i = 1 , mol % nat write ( unit , '(3f20.14)' ) mol % xyz (:, i ) * autoaa / mol % info % scale enddo else write ( unit , '(\"Direct\")' ) inv_lat = matinv_3x3 ( mol % lattice ) abc = matmul ( inv_lat , mol % xyz ) ! now write the fractional coordinates do i = 1 , mol % nat write ( unit , '(3f20.14)' ) abc (:, i ) enddo endif end subroutine write_vasp end module mctc_io_write_vasp","tags":"","loc":"sourcefile/vasp.f90.html"},{"title":"turbomole.f90 – MCTC-library","text":"Contents Modules mctc_io_write_turbomole Source Code turbomole.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_write_turbomole use mctc_env_accuracy , only : wp use mctc_io_structure , only : structure_type implicit none private public :: write_coord contains subroutine write_coord ( mol , unit ) class ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit integer :: iat write ( unit , '(a)' ) \"$coord\" do iat = 1 , mol % nat write ( unit , '(3es24.14, 6x, a)' ) mol % xyz (:, iat ), trim ( mol % sym ( mol % id ( iat ))) enddo write ( unit , '(a, 1x, i0)' ) \"$periodic\" , count ( mol % periodic ) if ( any ( mol % periodic )) then write ( unit , '(a)' ) \"$lattice bohr\" write ( unit , '(3f20.14)' ) mol % lattice endif write ( unit , '(a)' ) \"$end\" end subroutine write_coord end module mctc_io_write_turbomole","tags":"","loc":"sourcefile/turbomole.f90.html"},{"title":"genformat.f90 – MCTC-library","text":"Contents Modules mctc_io_write_genformat Source Code genformat.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_write_genformat use mctc_env_accuracy , only : wp use mctc_io_convert , only : autoaa use mctc_io_math , only : matinv_3x3 use mctc_io_symbols , only : to_symbol use mctc_io_structure , only : structure_type implicit none private public :: write_genformat contains subroutine write_genformat ( mol , unit ) class ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit integer :: iat , izp real ( wp ), parameter :: zero3 ( 3 ) = 0.0_wp real ( wp ), allocatable :: inv_lat (:, :) real ( wp ), allocatable :: abc (:, :) write ( unit , '(i0, 1x)' , advance = 'no' ) mol % nat if (. not . any ( mol % periodic )) then write ( unit , '(\"C\")' ) ! cluster else if ( mol % info % cartesian ) then write ( unit , '(\"S\")' ) ! supercell else write ( unit , '(\"F\")' ) ! fractional endif endif do izp = 1 , mol % nid write ( unit , '(1x, a)' , advance = 'no' ) trim ( mol % sym ( izp )) enddo write ( unit , '(a)' ) if (. not . any ( mol % periodic ) . or . mol % info % cartesian ) then ! now write the cartesian coordinates do iat = 1 , mol % nat write ( unit , '(2i5, 3es24.14)' ) iat , mol % id ( iat ), mol % xyz (:, iat ) * autoaa enddo else inv_lat = matinv_3x3 ( mol % lattice ) abc = matmul ( inv_lat , mol % xyz ) ! now write the fractional coordinates do iat = 1 , mol % nat write ( unit , '(2i5, 3es24.15)' ) iat , mol % id ( iat ), abc (:, iat ) enddo endif if ( any ( mol % periodic )) then ! scaling factor for lattice parameters is always one write ( unit , '(3f20.14)' ) zero3 ! write the lattice parameters write ( unit , '(3f20.14)' ) mol % lattice (:, :) * autoaa endif end subroutine write_genformat end module mctc_io_write_genformat","tags":"","loc":"sourcefile/genformat.f90.html"},{"title":"ctfile.f90 – MCTC-library","text":"Contents Modules mctc_io_write_ctfile Source Code ctfile.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_write_ctfile use mctc_env_accuracy , only : wp use mctc_io_convert , only : autoaa use mctc_io_structure , only : structure_type implicit none private public :: write_molfile , write_sdf contains subroutine write_sdf ( self , unit , energy , gnorm ) class ( structure_type ), intent ( in ) :: self integer , intent ( in ) :: unit real ( wp ), intent ( in ), optional :: energy real ( wp ), intent ( in ), optional :: gnorm !type(tb_buffer) :: sd_values character ( len = :), allocatable :: line character ( len =* ), parameter :: sd_format = & & '(\"> <\", a, \">\", /, f20.12, /)' call write_molfile ( self , unit ) !   sd_values = self%info !   call sd_values%reset !   do while(sd_values%next()) !      call sd_values%getline(line) !      write(unit, '(a)') line !   enddo if ( present ( energy )) then write ( unit , sd_format ) \"total energy / Eh\" , energy endif if ( present ( gnorm )) then write ( unit , sd_format ) \"gradient norm / Eh/a0\" , gnorm endif write ( unit , '(\"\")' ) end subroutine write_sdf subroutine write_molfile ( self , unit , comment_line ) class ( structure_type ), intent ( in ) :: self integer , intent ( in ) :: unit character ( len =* ), intent ( in ), optional :: comment_line integer , parameter :: list4 ( 4 ) = 0 integer :: iatom , ibond , iatoms ( 3 ), list12 ( 12 ) logical :: has_sdf_data integer , parameter :: charge_to_ccc ( - 3 : 3 ) = [ 7 , 6 , 5 , 0 , 3 , 2 , 1 ] character ( len = 8 ) :: date character ( len = 10 ) :: time call date_and_time ( date , time ) write ( unit , '(a)' ) write ( unit , '(2x, 3x, 5x, 3a2, a4, \"3D\")' ) & & date ( 5 : 6 ), date ( 7 : 8 ), date ( 3 : 4 ), time (: 4 ) if ( present ( comment_line )) then write ( unit , '(a)' ) comment_line else write ( unit , '(a)' ) end if write ( unit , '(3i3, 3x, 2i3, 12x, i3, 1x, a5)' ) & & self % nat , 0 , 0 , 0 , 0 , 999 , 'V2000' !&  len(self), len(self%bonds), 0, 0, 0, 999, 'V2000' has_sdf_data = allocated ( self % sdf ) do iatom = 1 , self % nat if ( has_sdf_data ) then list12 = [ self % sdf ( iatom )% isotope , 0 , 0 , 0 , 0 , self % sdf ( iatom )% valence , & & 0 , 0 , 0 , 0 , 0 , 0 ] else list12 = 0 endif write ( unit , '(3f10.4, 1x, a3, i2, 11i3)' ) & & self % xyz (:, iatom ) * autoaa , self % sym ( self % id ( iatom )), list12 enddo !   do ibond = 1, len(self%bonds) !      call self%bonds%get_item(ibond, iatoms) !      write(unit, '(7i3)') & !         & iatoms, list4 !   enddo if ( has_sdf_data ) then if ( sum ( self % sdf % charge ) /= nint ( self % charge )) then write ( unit , '(a, *(i3, 1x, i3, 1x, i3))' ) \"M  CHG\" , 1 , 1 , nint ( self % charge ) else do iatom = 1 , self % nat if ( self % sdf ( iatom )% charge /= 0 ) then write ( unit , '(a, *(i3, 1x, i3, 1x, i3))' ) & & \"M  CHG\" , 1 , iatom , self % sdf ( iatom )% charge end if end do end if else if ( nint ( self % charge ) /= 0 ) then write ( unit , '(a, *(i3, 1x, i3, 1x, i3))' ) \"M  CHG\" , 1 , 1 , nint ( self % charge ) end if end if write ( unit , '(a)' ) \"M  END\" end subroutine write_molfile end module mctc_io_write_ctfile","tags":"","loc":"sourcefile/ctfile.f90.html"},{"title":"info.f90 – MCTC-library","text":"Contents Modules mctc_io_structure_info Source Code info.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_structure_info use mctc_env_accuracy , only : wp implicit none private public :: pdb_data , sdf_data , structure_info public :: resize !> Atomic pdb data type. !> !> keeps information from PDB input that is currently not used by the !> caller program (like residues or chains) but is needed to write !> the PDB output eventually !> !>     ATOM   2461  HA3 GLY A 153     -10.977  -7.661   2.011  1.00  0.00           H !>     TER    2462      GLY A 153 !>     a6----i5---xa4--aa3-xai4--axxxf8.3----f8.3----f8.3----f6.2--f6.2--xxxxxxa4--a2a2 !>     HETATM 2463  CHA HEM A 154       9.596 -13.100  10.368  1.00  0.00           C type :: pdb_data logical :: het = . false . integer :: charge = 0 integer :: residue_number = 0 character ( len = 4 ) :: name = ' ' character ( len = 1 ) :: loc = ' ' character ( len = 3 ) :: residue = ' ' character ( len = 1 ) :: chains = ' ' character ( len = 1 ) :: code = ' ' character ( len = 4 ) :: segid = ' ' end type pdb_data !> SDF atomic data. !> !> We only support some entries, the rest is simply dropped. !> the format is: ddcccssshhhbbbvvvHHHrrriiimmmnnneee type :: sdf_data integer :: isotope = 0 !< d field integer :: charge = 0 !< c field integer :: hydrogens = 0 !< h field integer :: valence = 0 !< v field end type sdf_data !> structure input info !> !> contains informations from different input file formats type :: structure_info !> Vasp coordinate scaling information real ( wp ) :: scale = 1.0_wp !> Vasp selective dynamics keyword is present logical :: selective = . false . !> SDF 2D structure present logical :: two_dimensional = . false . !> SDF hydrogen query present or PDB without hydrogen atoms found logical :: missing_hydrogen = . false . !> Periodic coordinates should use preferrably cartesian coordinates logical :: cartesian = . true . !> Lattice information should use preferrably lattice vectors logical :: lattice = . true . !> Unit of the lattice vectors should be in Angstrom if possible logical :: angs_lattice = . false . !> Unit of the atomic coordinates should be in Angstrom if possible logical :: angs_coord = . false . end type structure_info interface resize module procedure resize_pdb_data end interface contains subroutine resize_pdb_data ( var , n ) type ( pdb_data ), allocatable , intent ( inout ) :: var (:) integer , intent ( in ), optional :: n type ( pdb_data ), allocatable :: tmp (:) integer :: length , current_length current_length = size ( var ) if ( current_length > 0 ) then if ( present ( n )) then if ( n <= current_length ) return length = n else length = current_length + current_length / 2 + 1 endif allocate ( tmp ( length ), source = pdb_data ()) tmp (: current_length ) = var (: current_length ) deallocate ( var ) call move_alloc ( tmp , var ) else if ( present ( n )) then length = n else length = 64 endif allocate ( var ( length ), source = pdb_data ()) endif end subroutine resize_pdb_data end module mctc_io_structure_info","tags":"","loc":"sourcefile/info.f90.html"},{"title":"gaussian.f90 – MCTC-library","text":"Contents Modules mctc_io_read_gaussian Source Code gaussian.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_read_gaussian use mctc_env_accuracy , only : wp use mctc_env_error , only : error_type , fatal_error use mctc_io_structure , only : structure_type , new implicit none private public :: read_gaussian_external contains subroutine read_gaussian_external ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error integer :: stat , n , mode , chrg , spin , iat , ii integer , allocatable :: at (:) real ( wp ), allocatable :: xyz (:,:) real ( wp ) :: coord ( 3 ), q read ( unit , '(4i10)' , iostat = stat ) n , mode , chrg , spin if ( stat . ne . 0 ) then call fatal_error ( error , \"Could not read number of atoms, check format!\" ) return end if if ( n <= 0 ) then call fatal_error ( error , \"Found no atoms, cannot work without atoms!\" ) return end if allocate ( xyz ( 3 , n )) allocate ( at ( n )) ii = 0 do while ( ii < n ) read ( unit , '(i10, 4f20.12)' , iostat = stat ) iat , coord , q if ( is_iostat_end ( stat )) exit if ( stat . ne . 0 ) then call fatal_error ( error , \"Could not read geometry from Gaussian file\" ) return end if if ( iat > 0 ) then ii = ii + 1 at ( ii ) = iat xyz (:, ii ) = coord else call fatal_error ( error , \"Invalid atomic number\" ) return end if end do call new ( self , at , xyz , charge = real ( chrg , wp ), uhf = spin ) if ( ii /= n ) then call fatal_error ( error , \"Atom number missmatch in Gaussian file\" ) return end if end subroutine read_gaussian_external end module mctc_io_read_gaussian","tags":"","loc":"sourcefile/gaussian.f90~2.html"},{"title":"pdb.f90 – MCTC-library","text":"Contents Modules mctc_io_read_pdb Source Code pdb.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_read_pdb use mctc_env_accuracy , only : wp use mctc_env_error , only : error_type , fatal_error use mctc_io_convert , only : aatoau use mctc_io_resize , only : resize use mctc_io_symbols , only : to_number , symbol_length use mctc_io_structure , only : structure_type , new use mctc_io_structure_info , only : pdb_data , resize use mctc_io_utils , only : getline implicit none private public :: read_pdb contains subroutine read_pdb ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error character ( len =* ), parameter :: pdb_format = & & '(6x,i5,1x,a4,a1,a3,1x,a1,i4,a1,3x,3f8.3,2f6.2,6x,a4,a2,a2)' integer , parameter :: p_initial_size = 1000 ! this is going to be a proteine integer :: iatom , jatom , iresidue , try , stat , atom_type real ( wp ) :: occ , temp , coords ( 3 ) real ( wp ), allocatable :: xyz (:,:) character ( len = 4 ) :: a_charge character ( len = :), allocatable :: line character ( len = symbol_length ), allocatable :: sym (:) type ( pdb_data ), allocatable :: pdb (:) allocate ( sym ( p_initial_size ), source = repeat ( ' ' , symbol_length )) allocate ( xyz ( 3 , p_initial_size ), source = 0.0_wp ) allocate ( pdb ( p_initial_size ), source = pdb_data ()) iatom = 0 iresidue = 0 stat = 0 do while ( stat == 0 ) call getline ( unit , line , stat ) if ( index ( line , 'END' ) == 1 ) exit if ( index ( line , 'ATOM' ) == 1 . or . index ( line , 'HETATM' ) == 1 ) then if ( iatom >= size ( xyz , 2 )) call resize ( xyz ) if ( iatom >= size ( sym )) call resize ( sym ) if ( iatom >= size ( pdb )) call resize ( pdb ) iatom = iatom + 1 pdb ( iatom )% het = index ( line , 'HETATM' ) == 1 read ( line , pdb_format ) & & jatom , pdb ( iatom )% name , pdb ( iatom )% loc , pdb ( iatom )% residue , & & pdb ( iatom )% chains , pdb ( iatom )% residue_number , pdb ( iatom )% code , & & coords , occ , temp , pdb ( iatom )% segid , sym ( iatom ), a_charge xyz (:, iatom ) = coords * aatoau atom_type = to_number ( sym ( iatom )) if ( atom_type == 0 ) then try = scan ( pdb ( iatom )% name , 'HCNOSPF' ) if ( try > 0 ) sym ( iatom ) = pdb ( iatom )% name ( try : try ) // ' ' pdb ( iatom )% charge = 0 else read ( a_charge ( 1 : 1 ), * , iostat = stat ) pdb ( iatom )% charge if ( stat /= 0 ) then stat = 0 pdb ( iatom )% charge = 0 else if ( a_charge ( 2 : 2 ) == '-' ) pdb ( iatom )% charge = - pdb ( iatom )% charge end if end if end if end do if ( stat /= 0 ) then call fatal_error ( error , \"could not read in coordinates, last line was: '\" // line // \"'\" ) return end if call new ( self , sym (: iatom ), xyz (:, : iatom )) !self%pdb = pdb(:iatom) self % charge = sum ( pdb (: iatom )% charge ) if (. not . all ( self % num > 0 )) then call fatal_error ( error , \"invalid atom type found\" ) return end if ! since PDB is used for biomolecules, this is a sensible check (prevents GIGO) if (. not . any ( self % num == 1 )) then call fatal_error ( error , \"You get no calculation today, please add hydrogen atoms first\" ) return end if end subroutine read_pdb end module mctc_io_read_pdb","tags":"","loc":"sourcefile/pdb.f90~2.html"},{"title":"xyz.f90 – MCTC-library","text":"Contents Modules mctc_io_read_xyz Source Code xyz.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_read_xyz use mctc_env_accuracy , only : wp use mctc_env_error , only : error_type , fatal_error use mctc_io_convert , only : aatoau use mctc_io_structure , only : structure_type , new use mctc_io_symbols , only : to_number , symbol_length use mctc_io_utils , only : getline implicit none private public :: read_xyz contains subroutine read_xyz ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error integer :: ii , n , iat , stat real ( wp ) :: x , y , z , conv real ( wp ), allocatable :: xyz (:, :) character ( len = symbol_length ) :: chdum character ( len = symbol_length ), allocatable :: sym (:) character ( len = :), allocatable :: line conv = aatoau read ( unit , * , iostat = stat ) n if ( stat /= 0 ) then call fatal_error ( error , \"Could not read number of atoms, check format!\" ) return end if if ( n . lt . 1 ) then call fatal_error ( error , \"Found no atoms, cannot work without atoms!\" ) return end if allocate ( sym ( n )) allocate ( xyz ( 3 , n )) ! drop next record read ( unit , '(a)' , iostat = stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of file\" ) return end if ii = 0 do while ( ii < n ) call getline ( unit , line , stat ) if ( is_iostat_end ( stat )) exit if ( stat /= 0 ) then call fatal_error ( error , \"Could not read geometry from xyz file\" ) return end if read ( line , * , iostat = stat ) chdum , x , y , z if ( stat /= 0 ) then call fatal_error ( error , \"Could not parse coordinates from xyz file\" ) return end if iat = to_number ( chdum ) if ( iat > 0 ) then ii = ii + 1 sym ( ii ) = trim ( chdum ) xyz (:, ii ) = [ x , y , z ] * conv else call fatal_error ( error , \"Unknown element symbol: '\" // trim ( chdum ) // \"'\" ) return end if end do if ( ii /= n ) then call fatal_error ( error , \"Atom number missmatch in xyz file\" ) return end if call new ( self , sym , xyz ) end subroutine read_xyz end module mctc_io_read_xyz","tags":"","loc":"sourcefile/xyz.f90~2.html"},{"title":"vasp.f90 – MCTC-library","text":"Contents Modules mctc_io_read_vasp Source Code vasp.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_read_vasp use mctc_env_accuracy , only : wp use mctc_env_error , only : error_type , fatal_error use mctc_io_convert , only : aatoau use mctc_io_resize , only : resize use mctc_io_structure , only : structure_type , new use mctc_io_structure_info , only : structure_info use mctc_io_symbols , only : to_number , symbol_length use mctc_io_utils , only : getline implicit none private public :: read_vasp logical , parameter :: debug = . false . contains subroutine read_vasp ( mol , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: mol !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error logical :: selective , cartesian integer :: i , j , k , nn , ntype , natoms , izp , stat integer , allocatable :: ncount (:) real ( wp ) :: ddum , latvec ( 3 ), scalar , coord ( 3 ), lattice ( 3 , 3 ) real ( wp ), allocatable :: xyz (:, :) character ( len = :), allocatable :: line character ( len = 2 * symbol_length ), allocatable :: args (:), args2 (:) character ( len = symbol_length ), allocatable :: sym (:) type ( structure_info ) :: info selective = . false . ! Selective dynamics cartesian = . true . ! Cartesian or direct lattice = 0 stat = 0 ntype = 0 ! first line contains the symbols of different atom types call getline ( unit , line , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of input encountered\" ) return end if if ( debug ) print '(\">\", a)' , line call parse_line ( line , args , ntype ) ! this line contains the global scaling factor, call getline ( unit , line , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of input encountered\" ) return end if if ( debug ) print '(\">\", a)' , line read ( line , * , iostat = stat ) ddum if ( stat /= 0 ) then call fatal_error ( error , \"Cannot read scaling factor from input\" ) return end if ! the Ang->au conversion is included in the scaling factor if ( debug ) print '(\"->\", g0)' , ddum scalar = ddum * aatoau ! reading the lattice constants do i = 1 , 3 call getline ( unit , line , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of lattice vectors encountered\" ) return end if if ( debug ) print '(\"->\", a)' , line read ( line , * , iostat = stat ) latvec if ( stat /= 0 ) then call fatal_error ( error , \"Cannot read lattice vectors from input\" ) return end if lattice (:, i ) = latvec * scalar end do ! Either here are the numbers of each element, ! or (>vasp.5.1) here are the element symbols call getline ( unit , line , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of input encountered\" ) return end if if ( debug ) print '(\">\", a)' , line ! try to verify that first element is actually a number i = max ( verify ( line , ' ' ), 1 ) j = scan ( line ( i :), ' ' ) - 2 + i if ( j < i ) j = len_trim ( line ) ! CONTCAR files have additional Element line here since vasp.5.1 if ( verify ( line ( i : j ), '1234567890' ) /= 0 ) then call parse_line ( line , args , ntype ) call getline ( unit , line , stat ) if ( debug ) print '(\"->\", a)' , line if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of input encountered\" ) return end if end if call parse_line ( line , args2 , nn ) if ( nn /= ntype ) then call fatal_error ( error , 'Number of atom types mismatches the number of counts' ) return end if allocate ( ncount ( nn ), source = 0 ) do i = 1 , nn read ( args2 ( i ), * , iostat = stat ) ncount ( i ) izp = to_number ( args ( i )) if ( izp < 1 . or . ncount ( i ) < 1 ) then call fatal_error ( error , \"Unknown element '\" // trim ( args ( i )) // \"' encountered\" ) return end if end do natoms = sum ( ncount ) allocate ( sym ( natoms )) allocate ( xyz ( 3 , natoms )) k = 0 do i = 1 , nn do j = 1 , ncount ( i ) k = k + 1 sym ( k ) = trim ( args ( i )) end do end do call getline ( unit , line , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Could not read POSCAR\" ) return end if if ( debug ) print '(\">\", a)' , line line = adjustl ( line ) if ( line (: 1 ). eq . 's' . or . line (: 1 ). eq . 'S' ) then selective = . true . call getline ( unit , line , stat ) if ( debug ) print '(\"->\", a)' , line if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of input encountered\" ) return end if line = adjustl ( line ) end if cartesian = ( line (: 1 ). eq . 'c' . or . line (: 1 ). eq . 'C' . or . & & line (: 1 ). eq . 'k' . or . line (: 1 ). eq . 'K' ) do i = 1 , natoms call getline ( unit , line , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of geometry encountered\" ) return end if if ( debug ) print '(\"-->\", a)' , line read ( line , * , iostat = stat ) coord if ( stat /= 0 ) then call fatal_error ( error , \"Cannot read geometry from input\" ) return end if if ( cartesian ) then xyz (:, i ) = coord * scalar else xyz (:, i ) = matmul ( lattice , coord ) end if end do ! save information about this POSCAR for later info = structure_info ( scale = ddum , selective = selective , cartesian = cartesian ) call new ( mol , sym , xyz , lattice = lattice , info = info ) end subroutine read_vasp subroutine parse_line ( line , args , nargs ) character ( len =* ), intent ( in ) :: line character ( len = 2 * symbol_length ), allocatable , intent ( out ) :: args (:) integer , intent ( out ) :: nargs integer , parameter :: p_initial_size = 50 integer :: istart , iend allocate ( args ( p_initial_size ), source = repeat ( ' ' , 2 * symbol_length )) istart = 1 iend = 1 nargs = 0 do while ( iend < len_trim ( line )) istart = verify ( line ( iend :), ' ' ) - 1 + iend iend = scan ( line ( istart :), ' ' ) - 1 + istart if ( iend < istart ) iend = len_trim ( line ) if ( nargs >= size ( args )) then call resize ( args ) end if nargs = nargs + 1 args ( nargs ) = trim ( line ( istart : iend )) end do end subroutine parse_line end module mctc_io_read_vasp","tags":"","loc":"sourcefile/vasp.f90~2.html"},{"title":"turbomole.f90 – MCTC-library","text":"Contents Modules mctc_io_read_turbomole Source Code turbomole.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_read_turbomole use mctc_env_accuracy , only : wp use mctc_env_error , only : error_type , fatal_error use mctc_io_constants , only : pi use mctc_io_convert , only : aatoau use mctc_io_resize , only : resize use mctc_io_structure , only : structure_type , new use mctc_io_structure_info , only : structure_info use mctc_io_symbols , only : to_number , symbol_length use mctc_io_utils , only : getline implicit none private public :: read_coord logical , parameter :: debug = . false . contains subroutine read_coord ( mol , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: mol !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error character , parameter :: flag = '$' integer , parameter :: p_initial_size = 100 integer , parameter :: p_nlv ( 3 ) = [ 1 , 4 , 9 ], p_ncp ( 3 ) = [ 1 , 3 , 6 ] logical :: has_coord , has_periodic , has_lattice , has_cell logical :: cartesian , coord_in_bohr , lattice_in_bohr , pbc ( 3 ) integer :: stat , iatom , i , j , natoms , periodic , cell_vectors real ( wp ) :: latvec ( 9 ), conv , cellpar ( 6 ), lattice ( 3 , 3 ) real ( wp ), allocatable :: coord (:, :), xyz (:, :) character ( len = :), allocatable :: line , cell_string , lattice_string character ( len = symbol_length ), allocatable :: sym (:) type ( structure_info ) :: info allocate ( sym ( p_initial_size ), source = repeat ( ' ' , symbol_length )) allocate ( coord ( 3 , p_initial_size ), source = 0.0_wp ) iatom = 0 periodic = 0 cell_vectors = 0 has_coord = . false . has_periodic = . false . has_lattice = . false . has_cell = . false . cartesian = . true . coord_in_bohr = . true . lattice_in_bohr = . true . lattice = 0.0_wp pbc = . false . stat = 0 do while ( stat == 0 ) call getline ( unit , line , stat ) if ( index ( line , flag ) == 1 ) then if ( index ( line , 'end' ) == 2 ) then exit else if (. not . has_coord . and . index ( line , 'coord' ) == 2 ) then has_coord = . true . ! $coord angs / $coord bohr / $coord frac call select_unit ( line , coord_in_bohr , cartesian ) coord_group : do while ( stat == 0 ) call getline ( unit , line , stat ) if ( index ( line , flag ) == 1 ) then backspace ( unit ) exit coord_group end if if ( iatom >= size ( coord , 2 )) call resize ( coord ) if ( iatom >= size ( sym )) call resize ( sym ) iatom = iatom + 1 read ( line , * , iostat = stat ) coord (:, iatom ), sym ( iatom ) end do coord_group else if (. not . has_periodic . and . index ( line , 'periodic' ) == 2 ) then has_periodic = . true . ! $periodic 0/1/2/3 read ( line ( 10 :), * , iostat = stat ) periodic else if (. not . has_lattice . and . index ( line , 'lattice' ) == 2 ) then has_lattice = . true . ! $lattice bohr / $lattice angs call select_unit ( line , lattice_in_bohr ) cell_vectors = 0 lattice_string = '' lattice_group : do while ( stat == 0 ) call getline ( unit , line , stat ) if ( index ( line , flag ) == 1 ) then backspace ( unit ) exit lattice_group end if cell_vectors = cell_vectors + 1 lattice_string = lattice_string // ' ' // line end do lattice_group else if (. not . has_cell . and . index ( line , 'cell' ) == 2 ) then has_cell = . true . ! $cell bohr / $cell angs call select_unit ( line , lattice_in_bohr ) call getline ( unit , cell_string , stat ) if ( debug ) print * , cell_string end if end if end do if (. not . has_coord . or . iatom == 0 ) then call fatal_error ( error , \"coordinates not present, cannot work without coordinates\" ) return end if if ( has_cell . and . has_lattice ) then call fatal_error ( error , \"both lattice and cell group are present\" ) return end if if (. not . has_periodic . and . ( has_cell . or . has_lattice )) then call fatal_error ( error , \"cell and lattice definition is present, but periodicity is not given\" ) return end if if ( periodic > 0 . and . . not .( has_cell . or . has_lattice )) then call fatal_error ( error , \"system is periodic but definition of lattice/cell is missing\" ) return end if if (. not . cartesian . and . periodic == 0 ) then call fatal_error ( error , \"fractional coordinates do not work for molecular systems\" ) return end if natoms = iatom allocate ( xyz ( 3 , natoms )) if ( any ( to_number ( sym (: natoms )) == 0 )) then call fatal_error ( error , \"unknown element present\" ) return end if if ( periodic > 0 ) pbc (: periodic ) = . true . if ( has_cell ) then read ( cell_string , * , iostat = stat ) latvec (: p_ncp ( periodic )) if ( debug ) print * , latvec (: p_ncp ( periodic )) if ( lattice_in_bohr ) then conv = 1.0_wp else conv = aatoau end if select case ( periodic ) case ( 1 ) cellpar = [ latvec ( 1 ) * conv , 1.0_wp , 1.0_wp , & & pi / 2 , pi / 2 , pi / 2 ] case ( 2 ) cellpar = [ latvec ( 1 ) * conv , latvec ( 2 ) * conv , 1.0_wp , & & pi / 2 , pi / 2 , latvec ( 3 ) * pi / 18 0.0_wp ] case ( 3 ) cellpar = [ latvec ( 1 : 3 ) * conv , latvec ( 4 : 6 ) * pi / 18 0.0_wp ] end select call cell_to_dlat ( cellpar , lattice ) end if if ( has_lattice ) then if ( cell_vectors /= periodic ) then call fatal_error ( error , \"number of cell vectors does not match periodicity\" ) return end if read ( lattice_string , * , iostat = stat ) latvec (: p_nlv ( periodic )) if ( lattice_in_bohr ) then conv = 1.0_wp else conv = aatoau end if j = 0 do i = 1 , periodic lattice (: periodic , i ) = latvec ( j + 1 : j + periodic ) * conv j = j + periodic end do end if if ( cartesian ) then if ( coord_in_bohr ) then conv = 1.0_wp else conv = aatoau end if xyz (:, :) = coord (:, : natoms ) * conv else xyz = matmul ( lattice , coord ) end if ! save data on input format info = structure_info ( cartesian = cartesian , lattice = has_lattice , & & angs_lattice = . not . lattice_in_bohr , angs_coord = . not . coord_in_bohr ) call new ( mol , sym (: natoms ), xyz , lattice = lattice , periodic = pbc , info = info ) contains subroutine select_unit ( line , in_bohr , cartesian ) character ( len =* ), intent ( in ) :: line logical , intent ( out ) :: in_bohr logical , intent ( out ), optional :: cartesian in_bohr = index ( line , ' angs' ) == 0 if ( present ( cartesian )) cartesian = index ( line , ' frac' ) == 0 end subroutine select_unit end subroutine read_coord !> Calculate the lattice vectors from a set of cell parameters pure subroutine cell_to_dlat ( cellpar , lattice ) !> Cell parameters real ( wp ), intent ( in ) :: cellpar ( 6 ) !> Direct lattice real ( wp ), intent ( out ) :: lattice ( 3 , 3 ) real ( wp ) :: dvol dvol = cell_to_dvol ( cellpar ) associate ( alen => cellpar ( 1 ), blen => cellpar ( 2 ), clen => cellpar ( 3 ), & & alp => cellpar ( 4 ), bet => cellpar ( 5 ), gam => cellpar ( 6 )) lattice ( 1 , 1 ) = alen lattice ( 2 , 1 ) = 0.0_wp lattice ( 3 , 1 ) = 0.0_wp lattice ( 3 , 2 ) = 0.0_wp lattice ( 1 , 2 ) = blen * cos ( gam ) lattice ( 2 , 2 ) = blen * sin ( gam ) lattice ( 1 , 3 ) = clen * cos ( bet ) lattice ( 2 , 3 ) = clen * ( cos ( alp ) - cos ( bet ) * cos ( gam )) / sin ( gam ); lattice ( 3 , 3 ) = dvol / ( alen * blen * sin ( gam )) end associate end subroutine cell_to_dlat !> Calculate the cell volume from a set of cell parameters pure function cell_to_dvol ( cellpar ) result ( dvol ) !> Cell parameters real ( wp ), intent ( in ) :: cellpar ( 6 ) !> Cell volume real ( wp ) :: dvol real ( wp ) :: vol2 associate ( alen => cellpar ( 1 ), blen => cellpar ( 2 ), clen => cellpar ( 3 ), & & alp => cellpar ( 4 ), bet => cellpar ( 5 ), gam => cellpar ( 6 ) ) vol2 = 1.0_wp - cos ( alp ) ** 2 - cos ( bet ) ** 2 - cos ( gam ) ** 2 & & + 2.0_wp * cos ( alp ) * cos ( bet ) * cos ( gam ) dvol = sqrt ( abs ( vol2 )) * alen * blen * clen ! return negative volume instead of imaginary one (means bad cell parameters) if ( vol2 < 0.0_wp ) dvol = - dvol ! this should not happen, but who knows... end associate end function cell_to_dvol end module mctc_io_read_turbomole","tags":"","loc":"sourcefile/turbomole.f90~2.html"},{"title":"genformat.f90 – MCTC-library","text":"Contents Modules mctc_io_read_genformat Source Code genformat.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_read_genformat use mctc_env_accuracy , only : wp use mctc_env_error , only : error_type , fatal_error use mctc_io_convert , only : aatoau use mctc_io_structure , only : structure_type , new use mctc_io_structure_info , only : structure_info use mctc_io_symbols , only : to_number , symbol_length use mctc_io_utils , only : getline implicit none private public :: read_genformat contains subroutine read_genformat ( mol , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: mol !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error character ( len = :), allocatable :: line integer :: natoms , nspecies , iatom , dummy , isp , ilat , stat , istart , iend logical :: cartesian , periodic real ( wp ) :: coord ( 3 ), lattice ( 3 , 3 ) character ( len = 1 ) :: variant character ( len = symbol_length ), allocatable :: species (:), sym (:) real ( wp ), allocatable :: xyz (:, :), abc (:, :) type ( structure_info ) :: info call next_line ( unit , line , stat ) read ( line , * , iostat = stat ) natoms , variant if ( stat /= 0 . or . natoms < 1 ) then call fatal_error ( error , 'could not read number of atoms' ) return end if allocate ( species ( natoms )) allocate ( sym ( natoms )) allocate ( xyz ( 3 , natoms )) allocate ( abc ( 3 , natoms )) select case ( variant ) case ( 'c' , 'C' ) cartesian = . true . periodic = . false . case ( 's' , 'S' ) cartesian = . true . periodic = . true . case ( 'f' , 'F' ) cartesian = . false . periodic = . true . case default call fatal_error ( error , 'invalid input version' ) return endselect call next_line ( unit , line , stat ) istart = 1 iend = 1 isp = 0 do while ( iend < len_trim ( line )) istart = verify ( line ( iend :), ' ' ) - 1 + iend iend = scan ( line ( istart :), ' ' ) - 1 + istart if ( iend < istart ) iend = len_trim ( line ) isp = isp + 1 species ( isp ) = trim ( line ( istart : iend )) end do nspecies = isp if ( any ( to_number ( species (: nspecies )) == 0 )) then call fatal_error ( error , 'unknown atom type present' ) return end if do iatom = 1 , natoms call next_line ( unit , line , stat ) read ( line , * , iostat = stat ) dummy , isp , coord if ( stat /= 0 ) then call fatal_error ( error , 'could not read coordinates from file' ) return end if sym ( iatom ) = species ( isp ) if ( cartesian ) then xyz (:, iatom ) = coord * aatoau else abc (:, iatom ) = coord end if end do if ( periodic ) then call next_line ( unit , line , stat ) if ( stat /= 0 ) then call fatal_error ( error , 'missing lattice information' ) return end if do ilat = 1 , 3 call next_line ( unit , line , stat ) read ( line , * , iostat = stat ) coord if ( stat /= 0 ) then call fatal_error ( error , 'could not read lattice from file' ) return end if lattice (:, ilat ) = coord * aatoau end do if (. not . cartesian ) then xyz = matmul ( lattice , abc ) end if info = structure_info ( cartesian = cartesian ) call new ( mol , sym , xyz , lattice = lattice , info = info ) else call new ( mol , sym , xyz ) end if contains subroutine next_line ( unit , line , stat ) integer , intent ( in ) :: unit character ( len = :), allocatable , intent ( out ) :: line integer , intent ( out ) :: stat integer :: ihash stat = 0 do while ( stat == 0 ) call getline ( unit , line , stat ) ihash = index ( line , '#' ) if ( ihash > 0 ) line = line (: ihash - 1 ) if ( len_trim ( line ) > 0 ) exit end do line = trim ( adjustl ( line )) end subroutine next_line end subroutine read_genformat end module mctc_io_read_genformat","tags":"","loc":"sourcefile/genformat.f90~2.html"},{"title":"ctfile.f90 – MCTC-library","text":"Contents Modules mctc_io_read_ctfile Source Code ctfile.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module mctc_io_read_ctfile use mctc_env_accuracy , only : wp use mctc_env_error , only : error_type , fatal_error use mctc_io_convert , only : aatoau use mctc_io_structure , only : structure_type , new use mctc_io_structure_info , only : sdf_data , structure_info use mctc_io_symbols , only : to_number , symbol_length use mctc_io_utils , only : getline implicit none private public :: read_sdf , read_molfile contains subroutine read_sdf ( mol , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: mol !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error character ( len = :), allocatable :: line integer :: stat call read_molfile ( mol , unit , error ) if ( allocated ( error )) return stat = 0 do while ( stat == 0 ) call getline ( unit , line , stat ) if ( index ( line , '' ) == 1 ) exit end do if ( stat /= 0 ) then call fatal_error ( error , \"Failed while reading SDF key-value pairs\" ) return end if end subroutine read_sdf subroutine read_molfile ( mol , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: mol !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error character ( len = :), allocatable :: line character ( len = :), allocatable :: name integer :: i , iatom , jatom , ibond , btype , atomtype integer :: stat , length , charge ( 2 , 15 ) integer :: number_of_atoms , number_of_bonds , number_of_atom_lists , & & chiral_flag , number_of_stext_entries , i999 integer :: list4 ( 4 ), list12 ( 12 ) real ( wp ) :: x , y , z character ( len = 2 ) :: sdf_dim character ( len = 3 ) :: symbol character ( len = 5 ) :: v2000 integer , parameter :: ccc_to_charge ( 0 : 7 ) = [ 0 , + 3 , + 2 , + 1 , 0 , - 1 , - 2 , - 3 ] logical :: two_dim character ( len = symbol_length ), allocatable :: sym (:) type ( sdf_data ), allocatable :: sdf (:) type ( structure_info ) :: info real ( wp ), allocatable :: xyz (:, :) two_dim = . false . call getline ( unit , name , stat ) call getline ( unit , line , stat ) read ( line , '(20x, a2)' , iostat = stat ) sdf_dim if ( stat == 0 ) then two_dim = sdf_dim == '2D' . or . sdf_dim == '2d' end if call getline ( unit , line , stat ) call getline ( unit , line , stat ) read ( line , '(3i3, 3x, 2i3, 12x, i3, 1x, a5)' , iostat = stat ) & & number_of_atoms , number_of_bonds , number_of_atom_lists , & & chiral_flag , number_of_stext_entries , i999 , v2000 if ( stat /= 0 ) then call fatal_error ( error , \"Cannot read header of molfile\" ) return end if allocate ( sdf ( number_of_atoms )) allocate ( xyz ( 3 , number_of_atoms )) allocate ( sym ( number_of_atoms )) do iatom = 1 , number_of_atoms call getline ( unit , line , stat ) read ( line , '(3f10.4, 1x, a3, i2, 11i3)' , iostat = stat ) & & x , y , z , symbol , list12 if ( stat /= 0 ) then call fatal_error ( error , \"Cannot read coordinates from connection table\" ) return end if atomtype = to_number ( symbol ) if ( atomtype == 0 ) then call fatal_error ( error , \"Unknown atom type '\" // trim ( symbol ) // \"' in connection table\" ) return end if xyz (:, iatom ) = [ x , y , z ] * aatoau sym ( iatom ) = trim ( symbol ) sdf ( iatom )% isotope = list12 ( 1 ) sdf ( iatom )% charge = ccc_to_charge ( list12 ( 2 )) ! drop doublet radical sdf ( iatom )% hydrogens = list12 ( 4 ) sdf ( iatom )% valence = list12 ( 6 ) end do !call mol%bonds%allocate(size=number_of_bonds, order=3) do ibond = 1 , number_of_bonds call getline ( unit , line , stat ) read ( line , '(7i3)' , iostat = stat ) & & iatom , jatom , btype , list4 if ( stat /= 0 ) then call fatal_error ( error , \"Cannot read topology from connection table\" ) return end if !call mol%bonds%push_back([iatom, jatom, btype]) end do do while ( stat == 0 ) call getline ( unit , line , stat ) if ( index ( line , 'M  END' ) == 1 ) exit if ( index ( line , 'M  CHG' ) == 1 ) then read ( line ( 7 : 9 ), * ) length read ( line ( 10 :), '(*(1x, i3, 1x, i3))' ) ( charge (:, i ), i = 1 , length ) do i = 1 , length sdf ( charge ( 1 , i ))% charge = charge ( 2 , i ) end do end if end do if ( stat /= 0 ) then call fatal_error ( error , \"Cannot read connection table\" ) return end if info = structure_info ( two_dimensional = two_dim , & & missing_hydrogen = any ( sdf % hydrogens > 1 )) call new ( mol , sym , xyz , charge = real ( sum ( sdf % charge ), wp ), info = info ) call move_alloc ( sdf , mol % sdf ) !if (len(name) > 0) mol%name = name end subroutine read_molfile end module mctc_io_read_ctfile","tags":"","loc":"sourcefile/ctfile.f90~2.html"},{"title":"main.f90 – MCTC-library","text":"Contents Programs main Source Code main.f90 Source Code ! This file is part of mctc-lib. ! ! Licensed under the Apache License, Version 2.0 (the \"License\"); ! you may not use this file except in compliance with the License. ! You may obtain a copy of the License at ! !     http://www.apache.org/licenses/LICENSE-2.0 ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. program main use , intrinsic :: iso_fortran_env , only : output_unit , error_unit , input_unit use mctc_env use mctc_io use mctc_io_symbols , only : to_symbol use mctc_version implicit none character ( len =* ), parameter :: prog_name = \"mctc-convert\" character ( len = :), allocatable :: input , output integer , allocatable :: input_format , output_format type ( structure_type ) :: mol type ( error_type ), allocatable :: error logical :: normalize call get_arguments ( input , input_format , output , output_format , normalize , error ) if ( allocated ( error )) then write ( error_unit , '(a)' ) error % message error stop end if if ( input == \"-\" ) then if (. not . allocated ( input_format )) input_format = filetype % xyz call read_structure ( mol , input_unit , input_format , error ) else call read_structure ( mol , input , error , input_format ) end if if ( allocated ( error )) then write ( error_unit , '(a)' ) error % message error stop end if if ( normalize ) then mol % sym = to_symbol ( mol % num ) end if if ( output == \"-\" ) then if (. not . allocated ( output_format )) output_format = filetype % xyz call write_structure ( mol , output_unit , output_format , error ) else call write_structure ( mol , output , error , output_format ) end if if ( allocated ( error )) then write ( error_unit , '(a)' ) error % message error stop end if contains subroutine help ( unit ) integer , intent ( in ) :: unit write ( unit , '(a, *(1x, a))' ) & \"Usage: \" // prog_name // \" [options] <input> <output>\" write ( unit , '(a)' ) & \"\" , & \"Read structure from input file and writes it to output file.\" , & \"The format is determined by the file extension or the format hint\" , & \"\" write ( unit , '(2x, a, t25, a)' ) & \"-i, --input <format>\" , \"Hint for the format of the input file\" , & \"-o, --output <format>\" , \"Hint for the format of the output file\" , & \"--normalize\" , \"Normalize all element symbols to capitalized format\" , & \"--version\" , \"Print program version and exit\" , & \"--help\" , \"Show this help message\" write ( unit , '(a)' ) end subroutine help subroutine version ( unit ) integer , intent ( in ) :: unit character ( len = :), allocatable :: version_string call get_mctc_version ( string = version_string ) write ( unit , '(a, *(1x, a))' ) & & prog_name , \"version\" , version_string end subroutine version !> Obtain the command line argument at a given index subroutine get_argument ( idx , arg ) !> Index of command line argument, range [0:command_argument_count()] integer , intent ( in ) :: idx !> Command line argument character ( len = :), allocatable , intent ( out ) :: arg integer :: length , stat call get_command_argument ( idx , length = length , status = stat ) if ( stat /= 0 ) then return endif allocate ( character ( len = length ) :: arg , stat = stat ) if ( stat /= 0 ) then return endif if ( length > 0 ) then call get_command_argument ( idx , arg , status = stat ) if ( stat /= 0 ) then deallocate ( arg ) return end if end if end subroutine get_argument subroutine get_arguments ( input , input_format , output , output_format , normalize , & & error ) !> Input file name character ( len = :), allocatable :: input !> Input file format integer , allocatable , intent ( out ) :: input_format !> Output file name character ( len = :), allocatable :: output !> Output file format integer , allocatable , intent ( out ) :: output_format !> Normalize element symbols logical , intent ( out ) :: normalize !> Error handling type ( error_type ), allocatable , intent ( out ) :: error integer :: iarg , narg character ( len = :), allocatable :: arg normalize = . false . iarg = 0 narg = command_argument_count () do while ( iarg < narg ) iarg = iarg + 1 call get_argument ( iarg , arg ) select case ( arg ) case ( \"--help\" ) call help ( output_unit ) stop case ( \"--version\" ) call version ( output_unit ) stop case default if (. not . allocated ( input )) then call move_alloc ( arg , input ) cycle end if if (. not . allocated ( output )) then call move_alloc ( arg , output ) cycle end if call fatal_error ( error , \"Too many positional arguments present\" ) exit case ( \"-i\" , \"--input\" ) iarg = iarg + 1 call get_argument ( iarg , arg ) if (. not . allocated ( arg )) then call fatal_error ( error , \"Missing argument for input format\" ) exit end if input_format = get_filetype ( \".\" // arg ) case ( \"-o\" , \"--output\" ) iarg = iarg + 1 call get_argument ( iarg , arg ) if (. not . allocated ( arg )) then call fatal_error ( error , \"Missing argument for output format\" ) exit end if output_format = get_filetype ( \".\" // arg ) case ( \"--normalize\" ) normalize = . true . end select end do if (. not .( allocated ( input ). and .( allocated ( output )))) then if (. not . allocated ( error )) then call help ( output_unit ) error stop end if end if end subroutine get_arguments end program main","tags":"","loc":"sourcefile/main.f90.html"},{"title":"testsuite_type – MCTC-library ","text":"type, public :: testsuite_type Collection of unit tests Contents Variables collect name Source Code testsuite_type Components Type Visibility Attributes Name Initial procedure(collect_interface), public, pointer, nopass :: collect => null() Entry point of the test character(len=:), public, allocatable :: name Name of the testsuite Source Code type :: testsuite_type !> Name of the testsuite character ( len = :), allocatable :: name !> Entry point of the test procedure ( collect_interface ), pointer , nopass :: collect => null () end type testsuite_type","tags":"","loc":"type/testsuite_type.html"},{"title":"unittest_type – MCTC-library ","text":"type, public :: unittest_type Declaration of a unit test Contents Variables name should_fail test Source Code unittest_type Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name Name of the test logical, public :: should_fail = .false. Whether test is supposed to fail procedure(test_interface), public, pointer, nopass :: test => null() Entry point of the test Source Code type :: unittest_type !> Name of the test character ( len = :), allocatable :: name !> Entry point of the test procedure ( test_interface ), pointer , nopass :: test => null () !> Whether test is supposed to fail logical :: should_fail = . false . end type unittest_type","tags":"","loc":"type/unittest_type.html"},{"title":"error_type – MCTC-library ","text":"type, public :: error_type Error message Contents Variables message stat Source Code error_type Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: message Payload of the error integer, public :: stat Error code Source Code type :: error_type !> Error code integer :: stat !> Payload of the error character ( len = :), allocatable :: message end type error_type","tags":"","loc":"type/error_type.html"},{"title":"structure_type – MCTC-library ","text":"type, public :: structure_type Structure representation Contents Variables charge id info lattice nat nid num pdb periodic sdf sym uhf xyz Source Code structure_type Components Type Visibility Attributes Name Initial real(kind=wp), public :: charge = 0.0_wp Total charge integer, public, allocatable :: id (:) Species identifier type( structure_info ), public :: info = structure_info() Vendor specific structure annotations real(kind=wp), public, allocatable :: lattice (:,:) Lattice parameters integer, public :: nat = 0 Number of atoms integer, public :: nid = 0 Number of unique species integer, public, allocatable :: num (:) Atomic number for each species type( pdb_data ), public, allocatable :: pdb (:) PDB atomic data annotations logical, public, allocatable :: periodic (:) Periodic directions type( sdf_data ), public, allocatable :: sdf (:) SDF atomic data annotations character(len=symbol_length), public, allocatable :: sym (:) Element symbol for each species integer, public :: uhf = 0 Number of unpaired electrons real(kind=wp), public, allocatable :: xyz (:,:) Cartesian coordinates, in Bohr Source Code type :: structure_type !> Number of atoms integer :: nat = 0 !> Number of unique species integer :: nid = 0 !> Species identifier integer , allocatable :: id (:) !> Atomic number for each species integer , allocatable :: num (:) !> Element symbol for each species character ( len = symbol_length ), allocatable :: sym (:) !> Cartesian coordinates, in Bohr real ( wp ), allocatable :: xyz (:, :) !> Number of unpaired electrons integer :: uhf = 0 !> Total charge real ( wp ) :: charge = 0.0_wp !> Lattice parameters real ( wp ), allocatable :: lattice (:, :) !> Periodic directions logical , allocatable :: periodic (:) !> Vendor specific structure annotations type ( structure_info ) :: info = structure_info () !> SDF atomic data annotations type ( sdf_data ), allocatable :: sdf (:) !> PDB atomic data annotations type ( pdb_data ), allocatable :: pdb (:) end type structure_type","tags":"","loc":"type/structure_type.html"},{"title":"pdb_data – MCTC-library ","text":"type, public :: pdb_data Atomic pdb data type. keeps information from PDB input that is currently not used by the\n caller program (like residues or chains) but is needed to write\n the PDB output eventually ATOM   2461  HA3 GLY A 153     -10.977  -7.661   2.011  1.00  0.00           H TER    2462      GLY A 153 a6----i5---xa4--aa3-xai4--axxxf8.3----f8.3----f8.3----f6.2--f6.2--xxxxxxa4--a2a2 HETATM 2463  CHA HEM A 154       9.596 -13.100  10.368  1.00  0.00           C Contents Variables chains charge code het loc name residue residue_number segid Source Code pdb_data Components Type Visibility Attributes Name Initial character(len=1), public :: chains = ' ' integer, public :: charge = 0 character(len=1), public :: code = ' ' logical, public :: het = .false. character(len=1), public :: loc = ' ' character(len=4), public :: name = ' ' character(len=3), public :: residue = ' ' integer, public :: residue_number = 0 character(len=4), public :: segid = ' ' Source Code type :: pdb_data logical :: het = . false . integer :: charge = 0 integer :: residue_number = 0 character ( len = 4 ) :: name = ' ' character ( len = 1 ) :: loc = ' ' character ( len = 3 ) :: residue = ' ' character ( len = 1 ) :: chains = ' ' character ( len = 1 ) :: code = ' ' character ( len = 4 ) :: segid = ' ' end type pdb_data","tags":"","loc":"type/pdb_data.html"},{"title":"sdf_data – MCTC-library ","text":"type, public :: sdf_data SDF atomic data. We only support some entries, the rest is simply dropped.\n the format is: ddcccssshhhbbbvvvHHHrrriiimmmnnneee Contents Variables charge hydrogens isotope valence Source Code sdf_data Components Type Visibility Attributes Name Initial integer, public :: charge = 0 c field integer, public :: hydrogens = 0 h field integer, public :: isotope = 0 d field integer, public :: valence = 0 v field Source Code type :: sdf_data integer :: isotope = 0 !< d field integer :: charge = 0 !< c field integer :: hydrogens = 0 !< h field integer :: valence = 0 !< v field end type sdf_data","tags":"","loc":"type/sdf_data.html"},{"title":"structure_info – MCTC-library ","text":"type, public :: structure_info structure input info contains informations from different input file formats Contents Variables angs_coord angs_lattice cartesian lattice missing_hydrogen scale selective two_dimensional Source Code structure_info Components Type Visibility Attributes Name Initial logical, public :: angs_coord = .false. Unit of the atomic coordinates should be in Angstrom if possible logical, public :: angs_lattice = .false. Unit of the lattice vectors should be in Angstrom if possible logical, public :: cartesian = .true. Periodic coordinates should use preferrably cartesian coordinates logical, public :: lattice = .true. Lattice information should use preferrably lattice vectors logical, public :: missing_hydrogen = .false. SDF hydrogen query present or PDB without hydrogen atoms found real(kind=wp), public :: scale = 1.0_wp Vasp coordinate scaling information logical, public :: selective = .false. Vasp selective dynamics keyword is present logical, public :: two_dimensional = .false. SDF 2D structure present Source Code type :: structure_info !> Vasp coordinate scaling information real ( wp ) :: scale = 1.0_wp !> Vasp selective dynamics keyword is present logical :: selective = . false . !> SDF 2D structure present logical :: two_dimensional = . false . !> SDF hydrogen query present or PDB without hydrogen atoms found logical :: missing_hydrogen = . false . !> Periodic coordinates should use preferrably cartesian coordinates logical :: cartesian = . true . !> Lattice information should use preferrably lattice vectors logical :: lattice = . true . !> Unit of the lattice vectors should be in Angstrom if possible logical :: angs_lattice = . false . !> Unit of the atomic coordinates should be in Angstrom if possible logical :: angs_coord = . false . end type structure_info","tags":"","loc":"type/structure_info.html"},{"title":"structure_reader – MCTC-library","text":"abstract interface public subroutine structure_reader(self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Description Read molecular structure data from formatted unit","tags":"","loc":"interface/structure_reader.html"},{"title":"get_mctc_version – MCTC-library","text":"public subroutine get_mctc_version(major, minor, patch, string) Getter function to retrieve mctc-lib version Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: major Major version number of the mctc-lib version integer, intent(out), optional :: minor Minor version number of the mctc-lib version integer, intent(out), optional :: patch Patch version number of the mctc-lib version character(len=:), intent(out), optional allocatable :: string String representation of the mctc-lib version Contents Source Code get_mctc_version Source Code subroutine get_mctc_version ( major , minor , patch , string ) !> Major version number of the mctc-lib version integer , intent ( out ), optional :: major !> Minor version number of the mctc-lib version integer , intent ( out ), optional :: minor !> Patch version number of the mctc-lib version integer , intent ( out ), optional :: patch !> String representation of the mctc-lib version character ( len = :), allocatable , intent ( out ), optional :: string if ( present ( major )) then major = mctc_version_compact ( 1 ) end if if ( present ( minor )) then minor = mctc_version_compact ( 2 ) end if if ( present ( patch )) then patch = mctc_version_compact ( 3 ) end if if ( present ( string )) then string = mctc_version_string end if end subroutine get_mctc_version","tags":"","loc":"proc/get_mctc_version.html"},{"title":"new_testsuite – MCTC-library","text":"public function new_testsuite(name, collect) result(self) Register a new testsuite Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of the testsuite procedure(collect_interface) :: collect Entry point to collect tests Return Value type( testsuite_type ) Newly registered testsuite Contents Source Code new_testsuite Source Code function new_testsuite ( name , collect ) result ( self ) !> Name of the testsuite character ( len =* ), intent ( in ) :: name !> Entry point to collect tests procedure ( collect_interface ) :: collect !> Newly registered testsuite type ( testsuite_type ) :: self self % name = name self % collect => collect end function new_testsuite","tags":"","loc":"proc/new_testsuite.html"},{"title":"new_unittest – MCTC-library","text":"public function new_unittest(name, test, should_fail) result(self) Register a new unit test Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of the test procedure(test_interface) :: test Entry point for the test logical, intent(in), optional :: should_fail Whether test is supposed to error or not Return Value type( unittest_type ) Newly registered test Contents Source Code new_unittest Source Code function new_unittest ( name , test , should_fail ) result ( self ) !> Name of the test character ( len =* ), intent ( in ) :: name !> Entry point for the test procedure ( test_interface ) :: test !> Whether test is supposed to error or not logical , intent ( in ), optional :: should_fail !> Newly registered test type ( unittest_type ) :: self self % name = name self % test => test if ( present ( should_fail )) self % should_fail = should_fail end function new_unittest","tags":"","loc":"proc/new_unittest.html"},{"title":"select_suite – MCTC-library","text":"public function select_suite(suites, name) result(pos) Select a test suite from all available suites Arguments Type Intent Optional Attributes Name type( testsuite_type ) :: suites (:) Available test suites character(len=*), intent(in) :: name Name identifying the test suite Return Value integer Selected test suite Contents Source Code select_suite Source Code function select_suite ( suites , name ) result ( pos ) !> Name identifying the test suite character ( len =* ), intent ( in ) :: name !> Available test suites type ( testsuite_type ) :: suites (:) !> Selected test suite integer :: pos integer :: it pos = 0 do it = 1 , size ( suites ) if ( name == suites ( it )% name ) then pos = it exit end if end do end function select_suite","tags":"","loc":"proc/select_suite.html"},{"title":"select_test – MCTC-library","text":"public function select_test(tests, name) result(pos) Select a unit test from all available tests Arguments Type Intent Optional Attributes Name type( unittest_type ) :: tests (:) Available unit tests character(len=*), intent(in) :: name Name identifying the test suite Return Value integer Selected test suite Contents Source Code select_test Source Code function select_test ( tests , name ) result ( pos ) !> Name identifying the test suite character ( len =* ), intent ( in ) :: name !> Available unit tests type ( unittest_type ) :: tests (:) !> Selected test suite integer :: pos integer :: it pos = 0 do it = 1 , size ( tests ) if ( name == tests ( it )% name ) then pos = it exit end if end do end function select_test","tags":"","loc":"proc/select_test.html"},{"title":"run_selected – MCTC-library","text":"public subroutine run_selected(collect, name, unit, stat) Driver for selective testing Arguments Type Intent Optional Attributes Name procedure(collect_interface) :: collect Collect tests character(len=*), intent(in) :: name Name of the selected test integer, intent(in) :: unit Unit for IO integer, intent(inout) :: stat Number of failed tests Contents Source Code run_selected Source Code subroutine run_selected ( collect , name , unit , stat ) !> Collect tests procedure ( collect_interface ) :: collect !> Name of the selected test character ( len =* ), intent ( in ) :: name !> Unit for IO integer , intent ( in ) :: unit !> Number of failed tests integer , intent ( inout ) :: stat type ( unittest_type ), allocatable :: testsuite (:) integer :: ii call collect ( testsuite ) ii = select_test ( testsuite , name ) if ( ii > 0 . and . ii <= size ( testsuite )) then call run_unittest ( testsuite ( ii ), unit , stat ) else write ( unit , fmt ) \"Available tests:\" do ii = 1 , size ( testsuite ) write ( unit , fmt ) \"-\" , testsuite ( ii )% name end do stat = - huge ( ii ) end if end subroutine run_selected","tags":"","loc":"proc/run_selected.html"},{"title":"run_testsuite – MCTC-library","text":"public subroutine run_testsuite(collect, unit, stat) Driver for testsuite Arguments Type Intent Optional Attributes Name procedure(collect_interface) :: collect Collect tests integer, intent(in) :: unit Unit for IO integer, intent(inout) :: stat Number of failed tests Contents Source Code run_testsuite Source Code subroutine run_testsuite ( collect , unit , stat ) !> Collect tests procedure ( collect_interface ) :: collect !> Unit for IO integer , intent ( in ) :: unit !> Number of failed tests integer , intent ( inout ) :: stat type ( unittest_type ), allocatable :: testsuite (:) integer :: ii call collect ( testsuite ) !$omp parallel do shared(testsuite, unit) reduction(+:stat) do ii = 1 , size ( testsuite ) !$omp critical(mctc_env_testsuite) write ( unit , '(1x, 3(1x, a), 1x, \"(\", i0, \"/\", i0, \")\")' ) & & \"Starting\" , testsuite ( ii )% name , \"...\" , ii , size ( testsuite ) !$omp end critical(mctc_env_testsuite) call run_unittest ( testsuite ( ii ), unit , stat ) end do end subroutine run_testsuite","tags":"","loc":"proc/run_testsuite.html"},{"title":"test_failed – MCTC-library","text":"public subroutine test_failed(error, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling character(len=*), intent(in) :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message Contents Source Code test_failed Source Code subroutine test_failed ( error , message , more ) !> Error handling type ( error_type ), allocatable , intent ( out ) :: error !> A detailed message describing the error character ( len =* ), intent ( in ) :: message !> Another line of error message character ( len =* ), intent ( in ), optional :: more allocate ( error ) error % stat = mctc_stat % fatal if ( present ( more )) then error % message = message // new_line ( 'a' ) // more else error % message = message end if end subroutine test_failed","tags":"","loc":"proc/test_failed.html"},{"title":"check – MCTC-library","text":"public interface check Contents Module Procedures check_stat check_float_sp check_float_dp check_int_i1 check_int_i2 check_int_i4 check_int_i8 check_bool check_string Module Procedures private subroutine check_stat(error, stat, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling integer, intent(in) :: stat Status of operation character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private subroutine check_float_sp(error, actual, expected, message, more, thr, rel) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling real(kind=sp), intent(in) :: actual Found floating point value real(kind=sp), intent(in) :: expected Expected floating point value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message real(kind=sp), intent(in), optional :: thr Allowed threshold for matching floating point values logical, intent(in), optional :: rel Check for relative errors instead private subroutine check_float_dp(error, actual, expected, message, more, thr, rel) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling real(kind=dp), intent(in) :: actual Found floating point value real(kind=dp), intent(in) :: expected Expected floating point value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message real(kind=dp), intent(in), optional :: thr Allowed threshold for matching floating point values logical, intent(in), optional :: rel Check for relative errors instead private subroutine check_int_i1(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling integer(kind=i1), intent(in) :: actual Found integer value integer(kind=i1), intent(in) :: expected Expected integer value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private subroutine check_int_i2(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling integer(kind=i2), intent(in) :: actual Found integer value integer(kind=i2), intent(in) :: expected Expected integer value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private subroutine check_int_i4(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling integer(kind=i4), intent(in) :: actual Found integer value integer(kind=i4), intent(in) :: expected Expected integer value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private subroutine check_int_i8(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling integer(kind=i8), intent(in) :: actual Found integer value integer(kind=i8), intent(in) :: expected Expected integer value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private subroutine check_bool(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling logical, intent(in) :: actual Found boolean value logical, intent(in) :: expected Expected boolean value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private subroutine check_string(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling character(len=*), intent(in) :: actual Found boolean value character(len=*), intent(in) :: expected Expected boolean value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message","tags":"","loc":"interface/check.html"},{"title":"fatal_error – MCTC-library","text":"public subroutine fatal_error(error, message, stat) A fatal error is encountered Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Instance of the error character(len=*), intent(in), optional :: message A detailed message describing the error and (optionally) offering advice integer, intent(in), optional :: stat Overwrite of the error code Contents Source Code fatal_error Source Code subroutine fatal_error ( error , message , stat ) !> Instance of the error type ( error_type ), allocatable , intent ( out ) :: error !> A detailed message describing the error and (optionally) offering advice character ( len =* ), intent ( in ), optional :: message !> Overwrite of the error code integer , intent ( in ), optional :: stat allocate ( error ) if ( present ( stat )) then error % stat = stat else error % stat = mctc_stat % fatal end if if ( present ( message )) then error % message = message else error % message = \"Fatal error\" end if end subroutine fatal_error","tags":"","loc":"proc/fatal_error.html"},{"title":"write_structure – MCTC-library","text":"public interface write_structure Contents Module Procedures write_structure_to_file write_structure_to_unit Module Procedures private subroutine write_structure_to_file(self, file, error, format) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self Instance of the molecular structure data character(len=*), intent(in) :: file Name of the file to read type( error_type ), intent(out), allocatable :: error Error handling integer, intent(in), optional :: format File type format hint private subroutine write_structure_to_unit(self, unit, ftype, error) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle integer, intent(in) :: ftype File type to read type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"interface/write_structure.html"},{"title":"resize – MCTC-library","text":"public interface resize Overloaded resize interface Contents Module Procedures resize_char resize_int resize_real resize_real_2d Module Procedures private pure subroutine resize_char(var, n) Reallocate list of characters Arguments Type Intent Optional Attributes Name character(len=*), intent(inout), allocatable :: var (:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size private pure subroutine resize_int(var, n) Reallocate list of integers Arguments Type Intent Optional Attributes Name integer, intent(inout), allocatable :: var (:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size private pure subroutine resize_real(var, n) Reallocate list of reals Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), allocatable :: var (:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size private pure subroutine resize_real_2d(var, n) Reallocate list of reals Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), allocatable :: var (:,:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size","tags":"","loc":"interface/resize.html"},{"title":"crossprod – MCTC-library","text":"public pure function crossprod(a, b) result(c) Implements the cross/vector product between two 3D vectors Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (3) First vector real(kind=wp), intent(in) :: b (3) Second vector Return Value real(kind=wp)\n  (3) Orthogonal vector Contents Source Code crossprod Source Code pure function crossprod ( a , b ) result ( c ) !> First vector real ( wp ), intent ( in ) :: a ( 3 ) !> Second vector real ( wp ), intent ( in ) :: b ( 3 ) !> Orthogonal vector real ( wp ) :: c ( 3 ) c ( 1 ) = a ( 2 ) * b ( 3 ) - b ( 2 ) * a ( 3 ) c ( 2 ) = a ( 3 ) * b ( 1 ) - b ( 3 ) * a ( 1 ) c ( 3 ) = a ( 1 ) * b ( 2 ) - b ( 1 ) * a ( 2 ) end function crossprod","tags":"","loc":"proc/crossprod.html"},{"title":"matdet_3x3 – MCTC-library","text":"public pure function matdet_3x3(a) result(det) Determinat of 3×3 matrix Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (3,3) Matrix Return Value real(kind=wp) Determinant Contents Source Code matdet_3x3 Source Code pure function matdet_3x3 ( a ) result ( det ) !> Matrix real ( wp ), intent ( in ) :: a ( 3 , 3 ) !> Determinant real ( wp ) :: det det = a ( 1 , 1 ) * a ( 2 , 2 ) * a ( 3 , 3 ) & & - a ( 1 , 1 ) * a ( 2 , 3 ) * a ( 3 , 2 ) & & - a ( 1 , 2 ) * a ( 2 , 1 ) * a ( 3 , 3 ) & & + a ( 1 , 2 ) * a ( 2 , 3 ) * a ( 3 , 1 ) & & + a ( 1 , 3 ) * a ( 2 , 1 ) * a ( 3 , 2 ) & & - a ( 1 , 3 ) * a ( 2 , 2 ) * a ( 3 , 1 ) end function matdet_3x3","tags":"","loc":"proc/matdet_3x3.html"},{"title":"matinv_3x3 – MCTC-library","text":"public pure function matinv_3x3(a) result(b) Performs a direct calculation of the inverse of a 3×3 matrix. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (3,3) Matrix Return Value real(kind=wp)\n  (3,3) Inverse matrix Contents Source Code matinv_3x3 Source Code pure function matinv_3x3 ( a ) result ( b ) !> Matrix real ( wp ), intent ( in ) :: a ( 3 , 3 ) !> Inverse matrix real ( wp ) :: b ( 3 , 3 ) real ( wp ) :: detinv ! Calculate the inverse determinant of the matrix detinv = 1.0_wp / matdet_3x3 ( a ) ! Calculate the inverse of the matrix b ( 1 , 1 ) = + detinv * ( a ( 2 , 2 ) * a ( 3 , 3 ) - a ( 2 , 3 ) * a ( 3 , 2 )) b ( 2 , 1 ) = - detinv * ( a ( 2 , 1 ) * a ( 3 , 3 ) - a ( 2 , 3 ) * a ( 3 , 1 )) b ( 3 , 1 ) = + detinv * ( a ( 2 , 1 ) * a ( 3 , 2 ) - a ( 2 , 2 ) * a ( 3 , 1 )) b ( 1 , 2 ) = - detinv * ( a ( 1 , 2 ) * a ( 3 , 3 ) - a ( 1 , 3 ) * a ( 3 , 2 )) b ( 2 , 2 ) = + detinv * ( a ( 1 , 1 ) * a ( 3 , 3 ) - a ( 1 , 3 ) * a ( 3 , 1 )) b ( 3 , 2 ) = - detinv * ( a ( 1 , 1 ) * a ( 3 , 2 ) - a ( 1 , 2 ) * a ( 3 , 1 )) b ( 1 , 3 ) = + detinv * ( a ( 1 , 2 ) * a ( 2 , 3 ) - a ( 1 , 3 ) * a ( 2 , 2 )) b ( 2 , 3 ) = - detinv * ( a ( 1 , 1 ) * a ( 2 , 3 ) - a ( 1 , 3 ) * a ( 2 , 1 )) b ( 3 , 3 ) = + detinv * ( a ( 1 , 1 ) * a ( 2 , 2 ) - a ( 1 , 2 ) * a ( 2 , 1 )) end function matinv_3x3","tags":"","loc":"proc/matinv_3x3.html"},{"title":"eigval_3x3 – MCTC-library","text":"public pure subroutine eigval_3x3(a, w) Calculates eigenvalues based on the trigonometric solution of A = pB + qI Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (3,3) The symmetric input matrix real(kind=wp), intent(out) :: w (3) Contains eigenvalues on exit Contents Source Code eigval_3x3 Source Code pure subroutine eigval_3x3 ( a , w ) !> The symmetric input matrix real ( wp ), intent ( in ) :: a ( 3 , 3 ) !> Contains eigenvalues on exit real ( wp ), intent ( out ) :: w ( 3 ) real ( wp ) :: q , p , r r = a ( 1 , 2 ) * a ( 1 , 2 ) + a ( 1 , 3 ) * a ( 1 , 3 ) + a ( 2 , 3 ) * a ( 2 , 3 ) q = ( a ( 1 , 1 ) + a ( 2 , 2 ) + a ( 3 , 3 )) / 3.0_wp w ( 1 ) = a ( 1 , 1 ) - q w ( 2 ) = a ( 2 , 2 ) - q w ( 3 ) = a ( 3 , 3 ) - q p = sqrt (( w ( 1 ) * w ( 1 ) + w ( 2 ) * w ( 2 ) + w ( 3 ) * w ( 3 ) + 2 * r ) / 6.0_wp ) r = ( w ( 1 ) * ( w ( 2 ) * w ( 3 ) - a ( 2 , 3 ) * a ( 2 , 3 )) & & - a ( 1 , 2 ) * ( a ( 1 , 2 ) * w ( 3 ) - a ( 2 , 3 ) * a ( 1 , 3 )) & & + a ( 1 , 3 ) * ( a ( 1 , 2 ) * a ( 2 , 3 ) - w ( 2 ) * a ( 1 , 3 ))) / ( p * p * p ) * 0.5_wp if ( r <= - 1.0_wp ) then r = 0.5_wp * twothirdpi else if ( r >= 1.0_wp ) then r = 0.0_wp else r = acos ( r ) / 3.0_wp end if w ( 3 ) = q + 2 * p * cos ( r ) w ( 1 ) = q + 2 * p * cos ( r + twothirdpi ) w ( 2 ) = 3 * q - w ( 1 ) - w ( 3 ) end subroutine eigval_3x3","tags":"","loc":"proc/eigval_3x3.html"},{"title":"eigvec_3x3 – MCTC-library","text":"public pure subroutine eigvec_3x3(a, w, q) Calculates eigenvector using an analytical method based on vector cross Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (3,3) real(kind=wp), intent(out) :: w (3) real(kind=wp), intent(out) :: q (3,3) Contents Source Code eigvec_3x3 Source Code pure subroutine eigvec_3x3 ( a , w , q ) real ( wp ), intent ( inout ) :: a ( 3 , 3 ) real ( wp ), intent ( out ) :: w ( 3 ) real ( wp ), intent ( out ) :: q ( 3 , 3 ) real ( wp ), parameter :: eps = epsilon ( 1.0_wp ) real ( wp ) norm , n1 , n2 , n3 , precon integer :: i w ( 1 ) = max ( abs ( a ( 1 , 1 )), abs ( a ( 1 , 2 ))) w ( 2 ) = max ( abs ( a ( 1 , 3 )), abs ( a ( 2 , 2 ))) w ( 3 ) = max ( abs ( a ( 2 , 3 )), abs ( a ( 3 , 3 ))) precon = max ( w ( 1 ), max ( w ( 2 ), w ( 3 ))) ! null matrix if ( precon < eps ) then w ( 1 ) = 0.0_wp w ( 2 ) = 0.0_wp w ( 3 ) = 0.0_wp q ( 1 , 1 ) = 1.0_wp q ( 2 , 2 ) = 1.0_wp q ( 3 , 3 ) = 1.0_wp q ( 1 , 2 ) = 0.0_wp q ( 1 , 3 ) = 0.0_wp q ( 2 , 3 ) = 0.0_wp q ( 2 , 1 ) = 0.0_wp q ( 3 , 1 ) = 0.0_wp q ( 3 , 2 ) = 0.0_wp return end if norm = 1.0_wp / precon a ( 1 , 1 ) = a ( 1 , 1 ) * norm a ( 1 , 2 ) = a ( 1 , 2 ) * norm a ( 2 , 2 ) = a ( 2 , 2 ) * norm a ( 1 , 3 ) = a ( 1 , 3 ) * norm a ( 2 , 3 ) = a ( 2 , 3 ) * norm a ( 3 , 3 ) = a ( 3 , 3 ) * norm ! Calculate eigenvalues call eigval_3x3 ( a , w ) ! Compute first eigenvector a ( 1 , 1 ) = a ( 1 , 1 ) - w ( 1 ) a ( 2 , 2 ) = a ( 2 , 2 ) - w ( 1 ) a ( 3 , 3 ) = a ( 3 , 3 ) - w ( 1 ) q ( 1 , 1 ) = a ( 1 , 2 ) * a ( 2 , 3 ) - a ( 1 , 3 ) * a ( 2 , 2 ) q ( 2 , 1 ) = a ( 1 , 3 ) * a ( 1 , 2 ) - a ( 1 , 1 ) * a ( 2 , 3 ) q ( 3 , 1 ) = a ( 1 , 1 ) * a ( 2 , 2 ) - a ( 1 , 2 ) * a ( 1 , 2 ) q ( 1 , 2 ) = a ( 1 , 2 ) * a ( 3 , 3 ) - a ( 1 , 3 ) * a ( 2 , 3 ) q ( 2 , 2 ) = a ( 1 , 3 ) * a ( 1 , 3 ) - a ( 1 , 1 ) * a ( 3 , 3 ) q ( 3 , 2 ) = a ( 1 , 1 ) * a ( 2 , 3 ) - a ( 1 , 2 ) * a ( 1 , 3 ) q ( 1 , 3 ) = a ( 2 , 2 ) * a ( 3 , 3 ) - a ( 2 , 3 ) * a ( 2 , 3 ) q ( 2 , 3 ) = a ( 2 , 3 ) * a ( 1 , 3 ) - a ( 1 , 2 ) * a ( 3 , 3 ) q ( 3 , 3 ) = a ( 1 , 2 ) * a ( 2 , 3 ) - a ( 2 , 2 ) * a ( 1 , 3 ) n1 = q ( 1 , 1 ) * q ( 1 , 1 ) + q ( 2 , 1 ) * q ( 2 , 1 ) + q ( 3 , 1 ) * q ( 3 , 1 ) n2 = q ( 1 , 2 ) * q ( 1 , 2 ) + q ( 2 , 2 ) * q ( 2 , 2 ) + q ( 3 , 2 ) * q ( 3 , 2 ) n3 = q ( 1 , 3 ) * q ( 1 , 3 ) + q ( 2 , 3 ) * q ( 2 , 3 ) + q ( 3 , 3 ) * q ( 3 , 3 ) norm = n1 i = 1 if ( n2 > norm ) then i = 2 norm = n1 end if if ( n3 > norm ) then i = 3 end if if ( i == 1 ) then norm = sqrt ( 1.0_wp / n1 ) q ( 1 , 1 ) = q ( 1 , 1 ) * norm q ( 2 , 1 ) = q ( 2 , 1 ) * norm q ( 3 , 1 ) = q ( 3 , 1 ) * norm else if ( i == 2 ) then norm = sqrt ( 1.0_wp / n2 ) q ( 1 , 1 ) = q ( 1 , 2 ) * norm q ( 2 , 1 ) = q ( 2 , 2 ) * norm q ( 3 , 1 ) = q ( 3 , 2 ) * norm else norm = sqrt ( 1.0_wp / n3 ) q ( 1 , 1 ) = q ( 1 , 3 ) * norm q ( 2 , 1 ) = q ( 2 , 3 ) * norm q ( 3 , 1 ) = q ( 3 , 3 ) * norm end if ! Robustly compute a right-hand orthonormal set (ev1, u, v) if ( abs ( q ( 1 , 1 )) > abs ( q ( 2 , 1 ))) then norm = sqrt ( 1.0_wp / ( q ( 1 , 1 ) * q ( 1 , 1 ) + q ( 3 , 1 ) * q ( 3 , 1 ))) q ( 1 , 2 ) = - q ( 3 , 1 ) * norm q ( 2 , 2 ) = 0.0_wp q ( 3 , 2 ) = + q ( 1 , 1 ) * norm else norm = sqrt ( 1.0_wp / ( q ( 2 , 1 ) * q ( 2 , 1 ) + q ( 3 , 1 ) * q ( 3 , 1 ))) q ( 1 , 2 ) = 0.0_wp q ( 2 , 2 ) = + q ( 3 , 1 ) * norm q ( 3 , 2 ) = - q ( 2 , 1 ) * norm end if q ( 1 , 3 ) = q ( 2 , 1 ) * q ( 3 , 2 ) - q ( 3 , 1 ) * q ( 2 , 2 ) q ( 2 , 3 ) = q ( 3 , 1 ) * q ( 1 , 2 ) - q ( 1 , 1 ) * q ( 3 , 2 ) q ( 3 , 3 ) = q ( 1 , 1 ) * q ( 2 , 2 ) - q ( 2 , 1 ) * q ( 1 , 2 ) ! Reset A a ( 1 , 1 ) = a ( 1 , 1 ) + w ( 1 ) a ( 2 , 2 ) = a ( 2 , 2 ) + w ( 1 ) a ( 3 , 3 ) = a ( 3 , 3 ) + w ( 1 ) ! A*U n1 = a ( 1 , 1 ) * q ( 1 , 2 ) + a ( 1 , 2 ) * q ( 2 , 2 ) + a ( 1 , 3 ) * q ( 3 , 2 ) n2 = a ( 1 , 2 ) * q ( 1 , 2 ) + a ( 2 , 2 ) * q ( 2 , 2 ) + a ( 2 , 3 ) * q ( 3 , 2 ) n3 = a ( 1 , 3 ) * q ( 1 , 2 ) + a ( 2 , 3 ) * q ( 2 , 2 ) + a ( 3 , 3 ) * q ( 3 , 2 ) ! A*V, note out of order computation a ( 3 , 3 ) = a ( 1 , 3 ) * q ( 1 , 3 ) + a ( 2 , 3 ) * q ( 2 , 3 ) + a ( 3 , 3 ) * q ( 3 , 3 ) a ( 1 , 3 ) = a ( 1 , 1 ) * q ( 1 , 3 ) + a ( 1 , 2 ) * q ( 2 , 3 ) + a ( 1 , 3 ) * q ( 3 , 3 ) a ( 2 , 3 ) = a ( 1 , 2 ) * q ( 1 , 3 ) + a ( 2 , 2 ) * q ( 2 , 3 ) + a ( 2 , 3 ) * q ( 3 , 3 ) ! UT*(A*U) - l2*E n1 = q ( 1 , 2 ) * n1 + q ( 2 , 2 ) * n2 + q ( 3 , 2 ) * n3 - w ( 2 ) ! UT*(A*V) n2 = q ( 1 , 2 ) * a ( 1 , 3 ) + q ( 2 , 2 ) * a ( 2 , 3 ) + q ( 3 , 2 ) * a ( 3 , 3 ) ! VT*(A*V) - l2*E n3 = q ( 1 , 3 ) * a ( 1 , 3 ) + q ( 2 , 3 ) * a ( 2 , 3 ) + q ( 3 , 3 ) * a ( 3 , 3 ) - w ( 2 ) if ( abs ( n1 ) >= abs ( n3 )) then norm = max ( abs ( n1 ), abs ( n2 )) if ( norm > eps ) then if ( abs ( n1 ) >= abs ( n2 )) then n2 = n2 / n1 n1 = sqrt ( 1.0_wp / ( 1.0_wp + n2 * n2 )) n2 = n2 * n1 else n1 = n1 / n2 n2 = sqrt ( 1.0_wp / ( 1.0_wp + n1 * n1 )) n1 = n1 * n2 end if q ( 1 , 2 ) = n2 * q ( 1 , 2 ) - n1 * q ( 1 , 3 ) q ( 2 , 2 ) = n2 * q ( 2 , 2 ) - n1 * q ( 2 , 3 ) q ( 3 , 2 ) = n2 * q ( 3 , 2 ) - n1 * q ( 3 , 3 ) end if else norm = max ( abs ( n3 ), abs ( n2 )) if ( norm > eps ) then if ( abs ( n3 ) >= abs ( n2 )) then n2 = n2 / n3 n3 = sqrt ( 1.0_wp / ( 1.0_wp + n2 * n2 )) n2 = n2 * n3 else n3 = n3 / n2 n2 = sqrt ( 1.0_wp / ( 1.0_wp + n3 * n3 )) n3 = n3 * n2 end if q ( 1 , 2 ) = n3 * q ( 1 , 2 ) - n2 * q ( 1 , 3 ) q ( 2 , 2 ) = n3 * q ( 2 , 2 ) - n2 * q ( 2 , 3 ) q ( 3 , 2 ) = n3 * q ( 3 , 2 ) - n2 * q ( 3 , 3 ) end if end if ! Calculate third eigenvector from cross product q ( 1 , 3 ) = q ( 2 , 1 ) * q ( 3 , 2 ) - q ( 3 , 1 ) * q ( 2 , 2 ) q ( 2 , 3 ) = q ( 3 , 1 ) * q ( 1 , 2 ) - q ( 1 , 1 ) * q ( 3 , 2 ) q ( 3 , 3 ) = q ( 1 , 1 ) * q ( 2 , 2 ) - q ( 2 , 1 ) * q ( 1 , 2 ) w ( 1 ) = w ( 1 ) * precon w ( 2 ) = w ( 2 ) * precon w ( 3 ) = w ( 3 ) * precon end subroutine eigvec_3x3","tags":"","loc":"proc/eigvec_3x3.html"},{"title":"get_filetype – MCTC-library","text":"public elemental function get_filetype(file) result(ftype) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file Name of the file Return Value integer File type from extension Contents Source Code get_filetype Source Code elemental function get_filetype ( file ) result ( ftype ) !> Name of the file character ( len =* ), intent ( in ) :: file !> File type from extension integer :: ftype integer :: iext , isep ftype = filetype % unknown iext = index ( file , '.' , back = . true .) isep = scan ( file , '/\\', back=.true.) if (iext > isep .and. iext > 0) then select case(to_lower(file(iext+1:))) case(' coord ', ' tmol ') ftype = filetype%tmol case(' xyz ') ftype = filetype%xyz case(' mol ') ftype = filetype%molfile case(' sdf ') ftype = filetype%sdf case(' poscar ', ' contcar ', ' vasp ') ftype = filetype%vasp case(' pdb ') ftype = filetype%pdb case(' gen ') ftype = filetype%gen case(' ein ') ftype = filetype%gaussian end select if (ftype /= filetype%unknown) return else iext = len(file) + 1 end if if (iext > isep) then select case(to_lower(file(isep+1:iext-1))) case(' coord ') ftype = filetype%tmol case(' poscar ', ' contcar ' ) ftype = filetype % vasp end select end if end function get_filetype","tags":"","loc":"proc/get_filetype.html"},{"title":"getline – MCTC-library","text":"public subroutine getline(unit, line, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Formatted IO unit character(len=:), intent(out), allocatable :: line Line to read integer, intent(out) :: iostat Status of operation character(len=:), optional allocatable :: iomsg Error message Contents Source Code getline Source Code subroutine getline ( unit , line , iostat , iomsg ) !> Formatted IO unit integer , intent ( in ) :: unit !> Line to read character ( len = :), allocatable , intent ( out ) :: line !> Status of operation integer , intent ( out ) :: iostat !> Error message character ( len = :), allocatable , optional :: iomsg integer , parameter :: bufsize = 512 character ( len = bufsize ) :: buffer character ( len = bufsize ) :: msg integer :: size integer :: stat allocate ( character ( len = 0 ) :: line ) do read ( unit , '(a)' , advance = 'no' , iostat = stat , iomsg = msg , size = size ) & & buffer if ( stat > 0 ) exit line = line // buffer (: size ) if ( stat < 0 ) then if ( is_iostat_eor ( stat )) then stat = 0 end if exit end if end do if ( stat /= 0 ) then if ( present ( iomsg )) iomsg = trim ( msg ) end if iostat = stat end subroutine getline","tags":"","loc":"proc/getline.html"},{"title":"get_structure_reader – MCTC-library","text":"public subroutine get_structure_reader(reader, ftype) Retrieve reader for corresponding file type Arguments Type Intent Optional Attributes Name procedure( structure_reader ), intent(out), pointer :: reader Reader for the specified file type integer, intent(in) :: ftype File type to read Contents Source Code get_structure_reader Source Code subroutine get_structure_reader ( reader , ftype ) !> Reader for the specified file type procedure ( structure_reader ), pointer , intent ( out ) :: reader !> File type to read integer , intent ( in ) :: ftype nullify ( reader ) select case ( ftype ) case ( filetype % xyz ) reader => read_xyz case ( filetype % molfile ) reader => read_molfile case ( filetype % pdb ) reader => read_pdb case ( filetype % gen ) reader => read_genformat case ( filetype % sdf ) reader => read_sdf case ( filetype % vasp ) reader => read_vasp case ( filetype % tmol ) reader => read_coord case ( filetype % gaussian ) reader => read_gaussian_external end select end subroutine get_structure_reader","tags":"","loc":"proc/get_structure_reader.html"},{"title":"read_structure – MCTC-library","text":"public interface read_structure Contents Module Procedures read_structure_from_file read_structure_from_unit Module Procedures private subroutine read_structure_from_file(self, file, error, format) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data character(len=*), intent(in) :: file Name of the file to read type( error_type ), intent(out), allocatable :: error Error handling integer, intent(in), optional :: format File type format hint private subroutine read_structure_from_unit(self, unit, ftype, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle integer, intent(in) :: ftype File type to read type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"interface/read_structure.html"},{"title":"to_lcsymbol – MCTC-library","text":"public elemental function to_lcsymbol(number) result(symbol) Convert atomic number to element symbol Arguments Type Intent Optional Attributes Name integer, intent(in) :: number Atomic number Return Value character(len=2) Element symbol Contents Source Code to_lcsymbol Source Code elemental function to_lcsymbol ( number ) result ( symbol ) !> Atomic number integer , intent ( in ) :: number !> Element symbol character ( len = 2 ) :: symbol call number_to_lcsymbol ( symbol , number ) end function to_lcsymbol","tags":"","loc":"proc/to_lcsymbol.html"},{"title":"to_number – MCTC-library","text":"public elemental function to_number(symbol) result(number) Convert element symbol to atomic number Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: symbol Element symbol Return Value integer Atomic number Contents Source Code to_number Source Code elemental function to_number ( symbol ) result ( number ) !> Element symbol character ( len =* ), intent ( in ) :: symbol !> Atomic number integer :: number call symbol_to_number ( number , symbol ) end function to_number","tags":"","loc":"proc/to_number.html"},{"title":"to_symbol – MCTC-library","text":"public elemental function to_symbol(number) result(symbol) Convert atomic number to element symbol Arguments Type Intent Optional Attributes Name integer, intent(in) :: number Atomic number Return Value character(len=2) Element symbol Contents Source Code to_symbol Source Code elemental function to_symbol ( number ) result ( symbol ) !> Atomic number integer , intent ( in ) :: number !> Element symbol character ( len = 2 ) :: symbol call number_to_symbol ( symbol , number ) end function to_symbol","tags":"","loc":"proc/to_symbol.html"},{"title":"collect_identical – MCTC-library","text":"public pure subroutine collect_identical(identity, mapping) Establish a mapping between unique atom types and species Arguments Type Intent Optional Attributes Name integer, intent(in) :: identity (:) Chemical identity integer, intent(out) :: mapping (:) Mapping from unique atoms Contents Source Code collect_identical Source Code pure subroutine collect_identical ( identity , mapping ) !> Chemical identity integer , intent ( in ) :: identity (:) !> Mapping from unique atoms integer , intent ( out ) :: mapping (:) integer :: iid , iat do iid = 1 , size ( mapping ) do iat = 1 , size ( identity ) if ( identity ( iat ) == iid ) then mapping ( iid ) = iat exit end if end do end do end subroutine collect_identical","tags":"","loc":"proc/collect_identical.html"},{"title":"number_to_lcsymbol – MCTC-library","text":"public elemental subroutine number_to_lcsymbol(symbol, number) Convert atomic number to element symbol Arguments Type Intent Optional Attributes Name character(len=2), intent(out) :: symbol Element symbol integer, intent(in) :: number Atomic number Contents Source Code number_to_lcsymbol Source Code elemental subroutine number_to_lcsymbol ( symbol , number ) !> Atomic number integer , intent ( in ) :: number !> Element symbol character ( len = 2 ), intent ( out ) :: symbol if ( number <= 0 . or . number > size ( lcpse )) then symbol = '--' else symbol = lcpse ( number ) endif end subroutine number_to_lcsymbol","tags":"","loc":"proc/number_to_lcsymbol.html"},{"title":"number_to_symbol – MCTC-library","text":"public elemental subroutine number_to_symbol(symbol, number) Convert atomic number to element symbol Arguments Type Intent Optional Attributes Name character(len=2), intent(out) :: symbol Element symbol integer, intent(in) :: number Atomic number Contents Source Code number_to_symbol Source Code elemental subroutine number_to_symbol ( symbol , number ) !> Atomic number integer , intent ( in ) :: number !> Element symbol character ( len = 2 ), intent ( out ) :: symbol if ( number <= 0 . or . number > size ( pse )) then symbol = '--' else symbol = pse ( number ) endif end subroutine number_to_symbol","tags":"","loc":"proc/number_to_symbol.html"},{"title":"symbol_to_number – MCTC-library","text":"public elemental subroutine symbol_to_number(number, symbol) Convert element symbol to atomic number Arguments Type Intent Optional Attributes Name integer, intent(out) :: number Atomic number character(len=*), intent(in) :: symbol Element symbol Contents Source Code symbol_to_number Source Code elemental subroutine symbol_to_number ( number , symbol ) !> Element symbol character ( len =* ), intent ( in ) :: symbol !> Atomic number integer , intent ( out ) :: number character ( len = 2 ) :: lcsymbol integer :: i , j , k , l number = 0 lcsymbol = '  ' k = 0 do j = 1 , len_trim ( symbol ) if ( k > 2 ) exit l = iachar ( symbol ( j : j )) if ( k >= 1 . and . l == iachar ( ' ' )) exit if ( k >= 1 . and . l == 9 ) exit if ( l >= iachar ( 'A' ) . and . l <= iachar ( 'Z' )) l = l + offset if ( l >= iachar ( 'a' ) . and . l <= iachar ( 'z' )) then k = k + 1 if ( k > 2 ) exit lcsymbol ( k : k ) = achar ( l ) endif enddo do i = 1 , size ( lcpse ) if ( lcsymbol == lcpse ( i )) then number = i exit endif enddo if ( number == 0 ) then select case ( lcsymbol ) case ( 'd ' , 't ' ) number = 1 end select end if end subroutine symbol_to_number","tags":"","loc":"proc/symbol_to_number.html"},{"title":"get_identity – MCTC-library","text":"public interface get_identity Get chemical identity Contents Module Procedures get_identity_number get_identity_symbol Module Procedures private pure subroutine get_identity_number(nid, identity, number) Get chemical identity from a list of atomic numbers Arguments Type Intent Optional Attributes Name integer, intent(out) :: nid Number of unique species integer, intent(out) :: identity (:) Chemical identity integer, intent(in) :: number (:) Ordinal numbers private pure subroutine get_identity_symbol(nid, identity, symbol) Get chemical identity from a list of element symbols Arguments Type Intent Optional Attributes Name integer, intent(out) :: nid Number of unique species integer, intent(out) :: identity (:) Chemical identity character(len=symbol_length), intent(in) :: symbol (:) Element symbols","tags":"","loc":"interface/get_identity.html"},{"title":"new_structure – MCTC-library","text":"public subroutine new_structure(self, num, sym, xyz, charge, uhf, lattice, periodic, info) Constructor for structure representations Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the structure representation integer, intent(in) :: num (:) Atomic numbers character(len=*), intent(in) :: sym (:) Element symbols real(kind=wp), intent(in) :: xyz (:,:) Cartesian coordinates real(kind=wp), intent(in), optional :: charge Total charge integer, intent(in), optional :: uhf Number of unpaired electrons real(kind=wp), intent(in), optional :: lattice (:,:) Lattice parameters logical, intent(in), optional :: periodic (:) Periodic directions type( structure_info ), intent(in), optional :: info Vendor specific structure information Contents Source Code new_structure Source Code subroutine new_structure ( self , num , sym , xyz , charge , uhf , lattice , periodic , info ) !> Instance of the structure representation type ( structure_type ), intent ( out ) :: self !> Atomic numbers integer , intent ( in ) :: num (:) !> Element symbols character ( len =* ), intent ( in ) :: sym (:) !> Cartesian coordinates real ( wp ), intent ( in ) :: xyz (:, :) !> Total charge real ( wp ), intent ( in ), optional :: charge !> Number of unpaired electrons integer , intent ( in ), optional :: uhf !> Lattice parameters real ( wp ), intent ( in ), optional :: lattice (:, :) !> Periodic directions logical , intent ( in ), optional :: periodic (:) !> Vendor specific structure information type ( structure_info ), intent ( in ), optional :: info integer :: ndim , iid integer , allocatable :: map (:) ndim = min ( size ( num , 1 ), size ( xyz , 2 ), size ( sym , 1 )) self % nat = ndim allocate ( self % id ( ndim )) allocate ( self % xyz ( 3 , ndim )) if ( present ( lattice )) then self % lattice = lattice end if if ( present ( periodic )) then self % periodic = periodic else if ( present ( lattice )) then allocate ( self % periodic ( 3 )) self % periodic (:) = . true . else allocate ( self % periodic ( 1 )) self % periodic (:) = . false . end if end if call get_identity ( self % nid , self % id , sym ) allocate ( map ( self % nid )) call collect_identical ( self % id , map ) allocate ( self % num ( self % nid )) allocate ( self % sym ( self % nid )) do iid = 1 , self % nid self % num ( iid ) = num ( map ( iid )) self % sym ( iid ) = sym ( map ( iid )) end do self % xyz (:, :) = xyz (:, : ndim ) if ( present ( charge )) then self % charge = charge else self % charge = 0.0_wp end if if ( present ( uhf )) then self % uhf = uhf else self % uhf = 0 end if if ( present ( info )) then self % info = info else self % info = structure_info () end if end subroutine new_structure","tags":"","loc":"proc/new_structure.html"},{"title":"new – MCTC-library","text":"public interface new Contents Module Procedures new_structure new_structure_num new_structure_sym Module Procedures public subroutine new_structure (self, num, sym, xyz, charge, uhf, lattice, periodic, info) Constructor for structure representations Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the structure representation integer, intent(in) :: num (:) Atomic numbers character(len=*), intent(in) :: sym (:) Element symbols real(kind=wp), intent(in) :: xyz (:,:) Cartesian coordinates real(kind=wp), intent(in), optional :: charge Total charge integer, intent(in), optional :: uhf Number of unpaired electrons real(kind=wp), intent(in), optional :: lattice (:,:) Lattice parameters logical, intent(in), optional :: periodic (:) Periodic directions type( structure_info ), intent(in), optional :: info Vendor specific structure information private subroutine new_structure_num(self, num, xyz, charge, uhf, lattice, periodic, info) Simplified constructor for structure representations Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the structure representation integer, intent(in) :: num (:) Atomic numbers real(kind=wp), intent(in) :: xyz (:,:) Cartesian coordinates real(kind=wp), intent(in), optional :: charge Total charge integer, intent(in), optional :: uhf Number of unpaired electrons real(kind=wp), intent(in), optional :: lattice (:,:) Lattice parameters logical, intent(in), optional :: periodic (:) Periodic directions type( structure_info ), intent(in), optional :: info Vendor specific structure information private subroutine new_structure_sym(self, sym, xyz, charge, uhf, lattice, periodic, info) Simplified constructor for structure representations Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the structure representation character(len=*), intent(in) :: sym (:) Element symbols real(kind=wp), intent(in) :: xyz (:,:) Cartesian coordinates real(kind=wp), intent(in), optional :: charge Total charge integer, intent(in), optional :: uhf Number of unpaired electrons real(kind=wp), intent(in), optional :: lattice (:,:) Lattice parameters logical, intent(in), optional :: periodic (:) Periodic directions type( structure_info ), intent(in), optional :: info Vendor specific structure information","tags":"","loc":"interface/new.html"},{"title":"write_gaussian_external – MCTC-library","text":"public subroutine write_gaussian_external(mol, unit) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(in) :: mol integer, intent(in) :: unit Contents Source Code write_gaussian_external Source Code subroutine write_gaussian_external ( mol , unit ) type ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit integer :: iat write ( unit , '(4i10)' ) mol % nat , 1 , nint ( mol % charge ), mol % uhf do iat = 1 , mol % nat write ( unit , '(i10,4f20.12)' ) mol % num ( mol % id ( iat )), mol % xyz (:, iat ), 0.0_wp end do end subroutine write_gaussian_external","tags":"","loc":"proc/write_gaussian_external.html"},{"title":"write_pdb – MCTC-library","text":"public subroutine write_pdb(mol, unit, number) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(in) :: mol integer, intent(in) :: unit integer, intent(in), optional :: number Contents Source Code write_pdb Source Code subroutine write_pdb ( mol , unit , number ) type ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit integer , intent ( in ), optional :: number character ( len = 6 ) :: w1 character ( len = 4 ) :: sym character ( len = 2 ) :: a_charge character ( len = 1 ) :: last_chain logical :: last_het integer :: offset , iat , jat real ( wp ) :: xyz ( 3 ) character ( len =* ), parameter :: pdb_format = & & '(a6,i5,1x,a4,a1,a3,1x,a1,i4,a1,3x,3f8.3,2f6.2,6x,a4,a2,a2)' if ( present ( number )) write ( unit , '(\"MODEL \",4x,i4)' ) number if ( allocated ( mol % pdb )) then offset = 0 last_chain = mol % pdb ( 1 )% chains last_het = mol % pdb ( 1 )% het do iat = 1 , mol % nat ! handle the terminator if ( mol % pdb ( iat )% het . neqv . last_het ) then write ( unit , '(\"TER   \",i5,6x,a3,1x,a1,i4)' ) iat + offset , & & mol % pdb ( iat - 1 )% residue , last_chain , mol % pdb ( iat )% residue_number last_het = . not . last_het offset = offset + 1 else if ( mol % pdb ( iat )% chains /= last_chain ) then write ( unit , '(\"TER   \",i5,6x,a3,1x,a1,i4)' ) iat + offset , & & mol % pdb ( iat - 1 )% residue , last_chain , mol % pdb ( iat )% residue_number offset = offset + 1 endif jat = iat + offset if ( mol % pdb ( iat )% het ) then w1 = \"HETATM\" else w1 = \"ATOM  \" endif sym = adjustr ( mol % sym ( mol % id ( iat ))( 1 : 2 )) xyz = mol % xyz (:, iat ) * autoaa if ( mol % pdb ( iat )% charge < 0 ) then write ( a_charge , '(i1,\"-\")' ) abs ( mol % pdb ( iat )% charge ) else if ( mol % pdb ( iat )% charge > 0 ) then write ( a_charge , '(i1,\"+\")' ) abs ( mol % pdb ( iat )% charge ) else a_charge = '  ' endif write ( unit , pdb_format ) & & w1 , jat , mol % pdb ( iat )% name , mol % pdb ( iat )% loc , & & mol % pdb ( iat )% residue , mol % pdb ( iat )% chains , mol % pdb ( iat )% residue_number , & & mol % pdb ( iat )% code , xyz , 1.0_wp , 0.0_wp , mol % pdb ( iat )% segid , & & sym , a_charge enddo else do iat = 1 , mol % nat w1 = \"HETATM\" sym = adjustr ( mol % sym ( mol % id ( iat ))( 1 : 2 )) xyz = mol % xyz (:, iat ) * autoaa a_charge = '  ' write ( unit , pdb_format ) & & w1 , iat , sym , \" \" , & & \"UNK\" , \"A\" , 1 , \" \" , xyz , 1.0_wp , 0.0_wp , \"    \" , & & sym , \"  \" enddo end if if ( present ( number )) then write ( unit , '(\"ENDMDL\")' ) else write ( unit , '(\"END\")' ) endif end subroutine write_pdb","tags":"","loc":"proc/write_pdb.html"},{"title":"write_xyz – MCTC-library","text":"public subroutine write_xyz(mol, unit, comment_line) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: mol integer, intent(in) :: unit character(len=*), intent(in), optional :: comment_line Contents Source Code write_xyz Source Code subroutine write_xyz ( mol , unit , comment_line ) class ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit character ( len =* ), intent ( in ), optional :: comment_line integer :: iat write ( unit , '(i0)' ) mol % nat if ( present ( comment_line )) then write ( unit , '(a)' ) comment_line else write ( unit , '(a)' ) end if do iat = 1 , mol % nat write ( unit , '(a4, 1x, 3es24.14)' ) & & mol % sym ( mol % id ( iat )), mol % xyz (:, iat ) * autoaa enddo end subroutine write_xyz","tags":"","loc":"proc/write_xyz.html"},{"title":"write_vasp – MCTC-library","text":"public subroutine write_vasp(mol, unit, comment_line) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: mol integer, intent(in) :: unit character(len=*), intent(in), optional :: comment_line Contents Source Code write_vasp Source Code subroutine write_vasp ( mol , unit , comment_line ) class ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit character ( len =* ), intent ( in ), optional :: comment_line integer :: i , j , izp integer , allocatable :: kinds (:), species (:) real ( wp ), allocatable :: inv_lat (:, :) real ( wp ), allocatable :: abc (:, :) allocate ( species ( mol % nat )) allocate ( kinds ( mol % nat ), source = 1 ) j = 0 izp = 0 do i = 1 , mol % nat if ( izp . eq . mol % id ( i )) then kinds ( j ) = kinds ( j ) + 1 else j = j + 1 izp = mol % id ( i ) species ( j ) = mol % id ( i ) endif enddo ! use vasp 5.x format if ( present ( comment_line )) then write ( unit , '(a)' ) comment_line else do i = 1 , j write ( unit , '(1x, a)' , advance = 'no' ) mol % sym ( species ( i )) enddo write ( unit , '(a)' ) end if ! scaling factor for lattice parameters is always one write ( unit , '(f20.14)' ) mol % info % scale ! write the lattice parameters if ( allocated ( mol % lattice )) then do i = 1 , 3 write ( unit , '(3f20.14)' ) mol % lattice (:, i ) * autoaa / mol % info % scale enddo else write ( unit , '(3f20.14)' ) spread ( 0.0_wp , 1 , 9 ) end if if ( present ( comment_line )) then do i = 1 , j write ( unit , '(1x, a)' , advance = 'no' ) mol % sym ( species ( i )) enddo write ( unit , '(a)' ) end if ! write the count of the consequtive atom types do i = 1 , j write ( unit , '(1x, i0)' , advance = 'no' ) kinds ( i ) enddo write ( unit , '(a)' ) deallocate ( kinds , species ) if ( mol % info % selective ) write ( unit , '(\"Selective\")' ) ! we write cartesian coordinates if (. not . allocated ( mol % lattice ) . or . mol % info % cartesian ) then write ( unit , '(\"Cartesian\")' ) ! now write the cartesian coordinates do i = 1 , mol % nat write ( unit , '(3f20.14)' ) mol % xyz (:, i ) * autoaa / mol % info % scale enddo else write ( unit , '(\"Direct\")' ) inv_lat = matinv_3x3 ( mol % lattice ) abc = matmul ( inv_lat , mol % xyz ) ! now write the fractional coordinates do i = 1 , mol % nat write ( unit , '(3f20.14)' ) abc (:, i ) enddo endif end subroutine write_vasp","tags":"","loc":"proc/write_vasp.html"},{"title":"write_coord – MCTC-library","text":"public subroutine write_coord(mol, unit) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: mol integer, intent(in) :: unit Contents Source Code write_coord Source Code subroutine write_coord ( mol , unit ) class ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit integer :: iat write ( unit , '(a)' ) \"$coord\" do iat = 1 , mol % nat write ( unit , '(3es24.14, 6x, a)' ) mol % xyz (:, iat ), trim ( mol % sym ( mol % id ( iat ))) enddo write ( unit , '(a, 1x, i0)' ) \"$periodic\" , count ( mol % periodic ) if ( any ( mol % periodic )) then write ( unit , '(a)' ) \"$lattice bohr\" write ( unit , '(3f20.14)' ) mol % lattice endif write ( unit , '(a)' ) \"$end\" end subroutine write_coord","tags":"","loc":"proc/write_coord.html"},{"title":"write_genformat – MCTC-library","text":"public subroutine write_genformat(mol, unit) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: mol integer, intent(in) :: unit Contents Source Code write_genformat Source Code subroutine write_genformat ( mol , unit ) class ( structure_type ), intent ( in ) :: mol integer , intent ( in ) :: unit integer :: iat , izp real ( wp ), parameter :: zero3 ( 3 ) = 0.0_wp real ( wp ), allocatable :: inv_lat (:, :) real ( wp ), allocatable :: abc (:, :) write ( unit , '(i0, 1x)' , advance = 'no' ) mol % nat if (. not . any ( mol % periodic )) then write ( unit , '(\"C\")' ) ! cluster else if ( mol % info % cartesian ) then write ( unit , '(\"S\")' ) ! supercell else write ( unit , '(\"F\")' ) ! fractional endif endif do izp = 1 , mol % nid write ( unit , '(1x, a)' , advance = 'no' ) trim ( mol % sym ( izp )) enddo write ( unit , '(a)' ) if (. not . any ( mol % periodic ) . or . mol % info % cartesian ) then ! now write the cartesian coordinates do iat = 1 , mol % nat write ( unit , '(2i5, 3es24.14)' ) iat , mol % id ( iat ), mol % xyz (:, iat ) * autoaa enddo else inv_lat = matinv_3x3 ( mol % lattice ) abc = matmul ( inv_lat , mol % xyz ) ! now write the fractional coordinates do iat = 1 , mol % nat write ( unit , '(2i5, 3es24.15)' ) iat , mol % id ( iat ), abc (:, iat ) enddo endif if ( any ( mol % periodic )) then ! scaling factor for lattice parameters is always one write ( unit , '(3f20.14)' ) zero3 ! write the lattice parameters write ( unit , '(3f20.14)' ) mol % lattice (:, :) * autoaa endif end subroutine write_genformat","tags":"","loc":"proc/write_genformat.html"},{"title":"write_molfile – MCTC-library","text":"public subroutine write_molfile(self, unit, comment_line) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in), optional :: comment_line Contents Source Code write_molfile Source Code subroutine write_molfile ( self , unit , comment_line ) class ( structure_type ), intent ( in ) :: self integer , intent ( in ) :: unit character ( len =* ), intent ( in ), optional :: comment_line integer , parameter :: list4 ( 4 ) = 0 integer :: iatom , ibond , iatoms ( 3 ), list12 ( 12 ) logical :: has_sdf_data integer , parameter :: charge_to_ccc ( - 3 : 3 ) = [ 7 , 6 , 5 , 0 , 3 , 2 , 1 ] character ( len = 8 ) :: date character ( len = 10 ) :: time call date_and_time ( date , time ) write ( unit , '(a)' ) write ( unit , '(2x, 3x, 5x, 3a2, a4, \"3D\")' ) & & date ( 5 : 6 ), date ( 7 : 8 ), date ( 3 : 4 ), time (: 4 ) if ( present ( comment_line )) then write ( unit , '(a)' ) comment_line else write ( unit , '(a)' ) end if write ( unit , '(3i3, 3x, 2i3, 12x, i3, 1x, a5)' ) & & self % nat , 0 , 0 , 0 , 0 , 999 , 'V2000' !&  len(self), len(self%bonds), 0, 0, 0, 999, 'V2000' has_sdf_data = allocated ( self % sdf ) do iatom = 1 , self % nat if ( has_sdf_data ) then list12 = [ self % sdf ( iatom )% isotope , 0 , 0 , 0 , 0 , self % sdf ( iatom )% valence , & & 0 , 0 , 0 , 0 , 0 , 0 ] else list12 = 0 endif write ( unit , '(3f10.4, 1x, a3, i2, 11i3)' ) & & self % xyz (:, iatom ) * autoaa , self % sym ( self % id ( iatom )), list12 enddo !   do ibond = 1, len(self%bonds) !      call self%bonds%get_item(ibond, iatoms) !      write(unit, '(7i3)') & !         & iatoms, list4 !   enddo if ( has_sdf_data ) then if ( sum ( self % sdf % charge ) /= nint ( self % charge )) then write ( unit , '(a, *(i3, 1x, i3, 1x, i3))' ) \"M  CHG\" , 1 , 1 , nint ( self % charge ) else do iatom = 1 , self % nat if ( self % sdf ( iatom )% charge /= 0 ) then write ( unit , '(a, *(i3, 1x, i3, 1x, i3))' ) & & \"M  CHG\" , 1 , iatom , self % sdf ( iatom )% charge end if end do end if else if ( nint ( self % charge ) /= 0 ) then write ( unit , '(a, *(i3, 1x, i3, 1x, i3))' ) \"M  CHG\" , 1 , 1 , nint ( self % charge ) end if end if write ( unit , '(a)' ) \"M  END\" end subroutine write_molfile","tags":"","loc":"proc/write_molfile.html"},{"title":"write_sdf – MCTC-library","text":"public subroutine write_sdf(self, unit, energy, gnorm) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self integer, intent(in) :: unit real(kind=wp), intent(in), optional :: energy real(kind=wp), intent(in), optional :: gnorm Contents Source Code write_sdf Source Code subroutine write_sdf ( self , unit , energy , gnorm ) class ( structure_type ), intent ( in ) :: self integer , intent ( in ) :: unit real ( wp ), intent ( in ), optional :: energy real ( wp ), intent ( in ), optional :: gnorm !type(tb_buffer) :: sd_values character ( len = :), allocatable :: line character ( len =* ), parameter :: sd_format = & & '(\"> <\", a, \">\", /, f20.12, /)' call write_molfile ( self , unit ) !   sd_values = self%info !   call sd_values%reset !   do while(sd_values%next()) !      call sd_values%getline(line) !      write(unit, '(a)') line !   enddo if ( present ( energy )) then write ( unit , sd_format ) \"total energy / Eh\" , energy endif if ( present ( gnorm )) then write ( unit , sd_format ) \"gradient norm / Eh/a0\" , gnorm endif write ( unit , '(\"\")' ) end subroutine write_sdf","tags":"","loc":"proc/write_sdf.html"},{"title":"resize – MCTC-library","text":"public interface resize Contents Module Procedures resize_pdb_data Module Procedures private subroutine resize_pdb_data(var, n) Arguments Type Intent Optional Attributes Name type( pdb_data ), intent(inout), allocatable :: var (:) integer, intent(in), optional :: n","tags":"","loc":"interface/resize~2.html"},{"title":"read_gaussian_external – MCTC-library","text":"public subroutine read_gaussian_external(self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Contents Source Code read_gaussian_external Source Code subroutine read_gaussian_external ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error integer :: stat , n , mode , chrg , spin , iat , ii integer , allocatable :: at (:) real ( wp ), allocatable :: xyz (:,:) real ( wp ) :: coord ( 3 ), q read ( unit , '(4i10)' , iostat = stat ) n , mode , chrg , spin if ( stat . ne . 0 ) then call fatal_error ( error , \"Could not read number of atoms, check format!\" ) return end if if ( n <= 0 ) then call fatal_error ( error , \"Found no atoms, cannot work without atoms!\" ) return end if allocate ( xyz ( 3 , n )) allocate ( at ( n )) ii = 0 do while ( ii < n ) read ( unit , '(i10, 4f20.12)' , iostat = stat ) iat , coord , q if ( is_iostat_end ( stat )) exit if ( stat . ne . 0 ) then call fatal_error ( error , \"Could not read geometry from Gaussian file\" ) return end if if ( iat > 0 ) then ii = ii + 1 at ( ii ) = iat xyz (:, ii ) = coord else call fatal_error ( error , \"Invalid atomic number\" ) return end if end do call new ( self , at , xyz , charge = real ( chrg , wp ), uhf = spin ) if ( ii /= n ) then call fatal_error ( error , \"Atom number missmatch in Gaussian file\" ) return end if end subroutine read_gaussian_external","tags":"","loc":"proc/read_gaussian_external.html"},{"title":"read_pdb – MCTC-library","text":"public subroutine read_pdb(self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Contents Source Code read_pdb Source Code subroutine read_pdb ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error character ( len =* ), parameter :: pdb_format = & & '(6x,i5,1x,a4,a1,a3,1x,a1,i4,a1,3x,3f8.3,2f6.2,6x,a4,a2,a2)' integer , parameter :: p_initial_size = 1000 ! this is going to be a proteine integer :: iatom , jatom , iresidue , try , stat , atom_type real ( wp ) :: occ , temp , coords ( 3 ) real ( wp ), allocatable :: xyz (:,:) character ( len = 4 ) :: a_charge character ( len = :), allocatable :: line character ( len = symbol_length ), allocatable :: sym (:) type ( pdb_data ), allocatable :: pdb (:) allocate ( sym ( p_initial_size ), source = repeat ( ' ' , symbol_length )) allocate ( xyz ( 3 , p_initial_size ), source = 0.0_wp ) allocate ( pdb ( p_initial_size ), source = pdb_data ()) iatom = 0 iresidue = 0 stat = 0 do while ( stat == 0 ) call getline ( unit , line , stat ) if ( index ( line , 'END' ) == 1 ) exit if ( index ( line , 'ATOM' ) == 1 . or . index ( line , 'HETATM' ) == 1 ) then if ( iatom >= size ( xyz , 2 )) call resize ( xyz ) if ( iatom >= size ( sym )) call resize ( sym ) if ( iatom >= size ( pdb )) call resize ( pdb ) iatom = iatom + 1 pdb ( iatom )% het = index ( line , 'HETATM' ) == 1 read ( line , pdb_format ) & & jatom , pdb ( iatom )% name , pdb ( iatom )% loc , pdb ( iatom )% residue , & & pdb ( iatom )% chains , pdb ( iatom )% residue_number , pdb ( iatom )% code , & & coords , occ , temp , pdb ( iatom )% segid , sym ( iatom ), a_charge xyz (:, iatom ) = coords * aatoau atom_type = to_number ( sym ( iatom )) if ( atom_type == 0 ) then try = scan ( pdb ( iatom )% name , 'HCNOSPF' ) if ( try > 0 ) sym ( iatom ) = pdb ( iatom )% name ( try : try ) // ' ' pdb ( iatom )% charge = 0 else read ( a_charge ( 1 : 1 ), * , iostat = stat ) pdb ( iatom )% charge if ( stat /= 0 ) then stat = 0 pdb ( iatom )% charge = 0 else if ( a_charge ( 2 : 2 ) == '-' ) pdb ( iatom )% charge = - pdb ( iatom )% charge end if end if end if end do if ( stat /= 0 ) then call fatal_error ( error , \"could not read in coordinates, last line was: '\" // line // \"'\" ) return end if call new ( self , sym (: iatom ), xyz (:, : iatom )) !self%pdb = pdb(:iatom) self % charge = sum ( pdb (: iatom )% charge ) if (. not . all ( self % num > 0 )) then call fatal_error ( error , \"invalid atom type found\" ) return end if ! since PDB is used for biomolecules, this is a sensible check (prevents GIGO) if (. not . any ( self % num == 1 )) then call fatal_error ( error , \"You get no calculation today, please add hydrogen atoms first\" ) return end if end subroutine read_pdb","tags":"","loc":"proc/read_pdb.html"},{"title":"read_xyz – MCTC-library","text":"public subroutine read_xyz(self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Contents Source Code read_xyz Source Code subroutine read_xyz ( self , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: self !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error integer :: ii , n , iat , stat real ( wp ) :: x , y , z , conv real ( wp ), allocatable :: xyz (:, :) character ( len = symbol_length ) :: chdum character ( len = symbol_length ), allocatable :: sym (:) character ( len = :), allocatable :: line conv = aatoau read ( unit , * , iostat = stat ) n if ( stat /= 0 ) then call fatal_error ( error , \"Could not read number of atoms, check format!\" ) return end if if ( n . lt . 1 ) then call fatal_error ( error , \"Found no atoms, cannot work without atoms!\" ) return end if allocate ( sym ( n )) allocate ( xyz ( 3 , n )) ! drop next record read ( unit , '(a)' , iostat = stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of file\" ) return end if ii = 0 do while ( ii < n ) call getline ( unit , line , stat ) if ( is_iostat_end ( stat )) exit if ( stat /= 0 ) then call fatal_error ( error , \"Could not read geometry from xyz file\" ) return end if read ( line , * , iostat = stat ) chdum , x , y , z if ( stat /= 0 ) then call fatal_error ( error , \"Could not parse coordinates from xyz file\" ) return end if iat = to_number ( chdum ) if ( iat > 0 ) then ii = ii + 1 sym ( ii ) = trim ( chdum ) xyz (:, ii ) = [ x , y , z ] * conv else call fatal_error ( error , \"Unknown element symbol: '\" // trim ( chdum ) // \"'\" ) return end if end do if ( ii /= n ) then call fatal_error ( error , \"Atom number missmatch in xyz file\" ) return end if call new ( self , sym , xyz ) end subroutine read_xyz","tags":"","loc":"proc/read_xyz.html"},{"title":"read_vasp – MCTC-library","text":"public subroutine read_vasp(mol, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: mol Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Contents Source Code read_vasp Source Code subroutine read_vasp ( mol , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: mol !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error logical :: selective , cartesian integer :: i , j , k , nn , ntype , natoms , izp , stat integer , allocatable :: ncount (:) real ( wp ) :: ddum , latvec ( 3 ), scalar , coord ( 3 ), lattice ( 3 , 3 ) real ( wp ), allocatable :: xyz (:, :) character ( len = :), allocatable :: line character ( len = 2 * symbol_length ), allocatable :: args (:), args2 (:) character ( len = symbol_length ), allocatable :: sym (:) type ( structure_info ) :: info selective = . false . ! Selective dynamics cartesian = . true . ! Cartesian or direct lattice = 0 stat = 0 ntype = 0 ! first line contains the symbols of different atom types call getline ( unit , line , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of input encountered\" ) return end if if ( debug ) print '(\">\", a)' , line call parse_line ( line , args , ntype ) ! this line contains the global scaling factor, call getline ( unit , line , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of input encountered\" ) return end if if ( debug ) print '(\">\", a)' , line read ( line , * , iostat = stat ) ddum if ( stat /= 0 ) then call fatal_error ( error , \"Cannot read scaling factor from input\" ) return end if ! the Ang->au conversion is included in the scaling factor if ( debug ) print '(\"->\", g0)' , ddum scalar = ddum * aatoau ! reading the lattice constants do i = 1 , 3 call getline ( unit , line , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of lattice vectors encountered\" ) return end if if ( debug ) print '(\"->\", a)' , line read ( line , * , iostat = stat ) latvec if ( stat /= 0 ) then call fatal_error ( error , \"Cannot read lattice vectors from input\" ) return end if lattice (:, i ) = latvec * scalar end do ! Either here are the numbers of each element, ! or (>vasp.5.1) here are the element symbols call getline ( unit , line , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of input encountered\" ) return end if if ( debug ) print '(\">\", a)' , line ! try to verify that first element is actually a number i = max ( verify ( line , ' ' ), 1 ) j = scan ( line ( i :), ' ' ) - 2 + i if ( j < i ) j = len_trim ( line ) ! CONTCAR files have additional Element line here since vasp.5.1 if ( verify ( line ( i : j ), '1234567890' ) /= 0 ) then call parse_line ( line , args , ntype ) call getline ( unit , line , stat ) if ( debug ) print '(\"->\", a)' , line if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of input encountered\" ) return end if end if call parse_line ( line , args2 , nn ) if ( nn /= ntype ) then call fatal_error ( error , 'Number of atom types mismatches the number of counts' ) return end if allocate ( ncount ( nn ), source = 0 ) do i = 1 , nn read ( args2 ( i ), * , iostat = stat ) ncount ( i ) izp = to_number ( args ( i )) if ( izp < 1 . or . ncount ( i ) < 1 ) then call fatal_error ( error , \"Unknown element '\" // trim ( args ( i )) // \"' encountered\" ) return end if end do natoms = sum ( ncount ) allocate ( sym ( natoms )) allocate ( xyz ( 3 , natoms )) k = 0 do i = 1 , nn do j = 1 , ncount ( i ) k = k + 1 sym ( k ) = trim ( args ( i )) end do end do call getline ( unit , line , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Could not read POSCAR\" ) return end if if ( debug ) print '(\">\", a)' , line line = adjustl ( line ) if ( line (: 1 ). eq . 's' . or . line (: 1 ). eq . 'S' ) then selective = . true . call getline ( unit , line , stat ) if ( debug ) print '(\"->\", a)' , line if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of input encountered\" ) return end if line = adjustl ( line ) end if cartesian = ( line (: 1 ). eq . 'c' . or . line (: 1 ). eq . 'C' . or . & & line (: 1 ). eq . 'k' . or . line (: 1 ). eq . 'K' ) do i = 1 , natoms call getline ( unit , line , stat ) if ( stat /= 0 ) then call fatal_error ( error , \"Unexpected end of geometry encountered\" ) return end if if ( debug ) print '(\"-->\", a)' , line read ( line , * , iostat = stat ) coord if ( stat /= 0 ) then call fatal_error ( error , \"Cannot read geometry from input\" ) return end if if ( cartesian ) then xyz (:, i ) = coord * scalar else xyz (:, i ) = matmul ( lattice , coord ) end if end do ! save information about this POSCAR for later info = structure_info ( scale = ddum , selective = selective , cartesian = cartesian ) call new ( mol , sym , xyz , lattice = lattice , info = info ) end subroutine read_vasp","tags":"","loc":"proc/read_vasp.html"},{"title":"read_coord – MCTC-library","text":"public subroutine read_coord(mol, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: mol Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Contents Source Code read_coord Source Code subroutine read_coord ( mol , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: mol !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error character , parameter :: flag = '$' integer , parameter :: p_initial_size = 100 integer , parameter :: p_nlv ( 3 ) = [ 1 , 4 , 9 ], p_ncp ( 3 ) = [ 1 , 3 , 6 ] logical :: has_coord , has_periodic , has_lattice , has_cell logical :: cartesian , coord_in_bohr , lattice_in_bohr , pbc ( 3 ) integer :: stat , iatom , i , j , natoms , periodic , cell_vectors real ( wp ) :: latvec ( 9 ), conv , cellpar ( 6 ), lattice ( 3 , 3 ) real ( wp ), allocatable :: coord (:, :), xyz (:, :) character ( len = :), allocatable :: line , cell_string , lattice_string character ( len = symbol_length ), allocatable :: sym (:) type ( structure_info ) :: info allocate ( sym ( p_initial_size ), source = repeat ( ' ' , symbol_length )) allocate ( coord ( 3 , p_initial_size ), source = 0.0_wp ) iatom = 0 periodic = 0 cell_vectors = 0 has_coord = . false . has_periodic = . false . has_lattice = . false . has_cell = . false . cartesian = . true . coord_in_bohr = . true . lattice_in_bohr = . true . lattice = 0.0_wp pbc = . false . stat = 0 do while ( stat == 0 ) call getline ( unit , line , stat ) if ( index ( line , flag ) == 1 ) then if ( index ( line , 'end' ) == 2 ) then exit else if (. not . has_coord . and . index ( line , 'coord' ) == 2 ) then has_coord = . true . ! $coord angs / $coord bohr / $coord frac call select_unit ( line , coord_in_bohr , cartesian ) coord_group : do while ( stat == 0 ) call getline ( unit , line , stat ) if ( index ( line , flag ) == 1 ) then backspace ( unit ) exit coord_group end if if ( iatom >= size ( coord , 2 )) call resize ( coord ) if ( iatom >= size ( sym )) call resize ( sym ) iatom = iatom + 1 read ( line , * , iostat = stat ) coord (:, iatom ), sym ( iatom ) end do coord_group else if (. not . has_periodic . and . index ( line , 'periodic' ) == 2 ) then has_periodic = . true . ! $periodic 0/1/2/3 read ( line ( 10 :), * , iostat = stat ) periodic else if (. not . has_lattice . and . index ( line , 'lattice' ) == 2 ) then has_lattice = . true . ! $lattice bohr / $lattice angs call select_unit ( line , lattice_in_bohr ) cell_vectors = 0 lattice_string = '' lattice_group : do while ( stat == 0 ) call getline ( unit , line , stat ) if ( index ( line , flag ) == 1 ) then backspace ( unit ) exit lattice_group end if cell_vectors = cell_vectors + 1 lattice_string = lattice_string // ' ' // line end do lattice_group else if (. not . has_cell . and . index ( line , 'cell' ) == 2 ) then has_cell = . true . ! $cell bohr / $cell angs call select_unit ( line , lattice_in_bohr ) call getline ( unit , cell_string , stat ) if ( debug ) print * , cell_string end if end if end do if (. not . has_coord . or . iatom == 0 ) then call fatal_error ( error , \"coordinates not present, cannot work without coordinates\" ) return end if if ( has_cell . and . has_lattice ) then call fatal_error ( error , \"both lattice and cell group are present\" ) return end if if (. not . has_periodic . and . ( has_cell . or . has_lattice )) then call fatal_error ( error , \"cell and lattice definition is present, but periodicity is not given\" ) return end if if ( periodic > 0 . and . . not .( has_cell . or . has_lattice )) then call fatal_error ( error , \"system is periodic but definition of lattice/cell is missing\" ) return end if if (. not . cartesian . and . periodic == 0 ) then call fatal_error ( error , \"fractional coordinates do not work for molecular systems\" ) return end if natoms = iatom allocate ( xyz ( 3 , natoms )) if ( any ( to_number ( sym (: natoms )) == 0 )) then call fatal_error ( error , \"unknown element present\" ) return end if if ( periodic > 0 ) pbc (: periodic ) = . true . if ( has_cell ) then read ( cell_string , * , iostat = stat ) latvec (: p_ncp ( periodic )) if ( debug ) print * , latvec (: p_ncp ( periodic )) if ( lattice_in_bohr ) then conv = 1.0_wp else conv = aatoau end if select case ( periodic ) case ( 1 ) cellpar = [ latvec ( 1 ) * conv , 1.0_wp , 1.0_wp , & & pi / 2 , pi / 2 , pi / 2 ] case ( 2 ) cellpar = [ latvec ( 1 ) * conv , latvec ( 2 ) * conv , 1.0_wp , & & pi / 2 , pi / 2 , latvec ( 3 ) * pi / 18 0.0_wp ] case ( 3 ) cellpar = [ latvec ( 1 : 3 ) * conv , latvec ( 4 : 6 ) * pi / 18 0.0_wp ] end select call cell_to_dlat ( cellpar , lattice ) end if if ( has_lattice ) then if ( cell_vectors /= periodic ) then call fatal_error ( error , \"number of cell vectors does not match periodicity\" ) return end if read ( lattice_string , * , iostat = stat ) latvec (: p_nlv ( periodic )) if ( lattice_in_bohr ) then conv = 1.0_wp else conv = aatoau end if j = 0 do i = 1 , periodic lattice (: periodic , i ) = latvec ( j + 1 : j + periodic ) * conv j = j + periodic end do end if if ( cartesian ) then if ( coord_in_bohr ) then conv = 1.0_wp else conv = aatoau end if xyz (:, :) = coord (:, : natoms ) * conv else xyz = matmul ( lattice , coord ) end if ! save data on input format info = structure_info ( cartesian = cartesian , lattice = has_lattice , & & angs_lattice = . not . lattice_in_bohr , angs_coord = . not . coord_in_bohr ) call new ( mol , sym (: natoms ), xyz , lattice = lattice , periodic = pbc , info = info ) contains subroutine select_unit ( line , in_bohr , cartesian ) character ( len =* ), intent ( in ) :: line logical , intent ( out ) :: in_bohr logical , intent ( out ), optional :: cartesian in_bohr = index ( line , ' angs' ) == 0 if ( present ( cartesian )) cartesian = index ( line , ' frac' ) == 0 end subroutine select_unit end subroutine read_coord","tags":"","loc":"proc/read_coord.html"},{"title":"read_genformat – MCTC-library","text":"public subroutine read_genformat(mol, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: mol Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Contents Source Code read_genformat Source Code subroutine read_genformat ( mol , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: mol !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error character ( len = :), allocatable :: line integer :: natoms , nspecies , iatom , dummy , isp , ilat , stat , istart , iend logical :: cartesian , periodic real ( wp ) :: coord ( 3 ), lattice ( 3 , 3 ) character ( len = 1 ) :: variant character ( len = symbol_length ), allocatable :: species (:), sym (:) real ( wp ), allocatable :: xyz (:, :), abc (:, :) type ( structure_info ) :: info call next_line ( unit , line , stat ) read ( line , * , iostat = stat ) natoms , variant if ( stat /= 0 . or . natoms < 1 ) then call fatal_error ( error , 'could not read number of atoms' ) return end if allocate ( species ( natoms )) allocate ( sym ( natoms )) allocate ( xyz ( 3 , natoms )) allocate ( abc ( 3 , natoms )) select case ( variant ) case ( 'c' , 'C' ) cartesian = . true . periodic = . false . case ( 's' , 'S' ) cartesian = . true . periodic = . true . case ( 'f' , 'F' ) cartesian = . false . periodic = . true . case default call fatal_error ( error , 'invalid input version' ) return endselect call next_line ( unit , line , stat ) istart = 1 iend = 1 isp = 0 do while ( iend < len_trim ( line )) istart = verify ( line ( iend :), ' ' ) - 1 + iend iend = scan ( line ( istart :), ' ' ) - 1 + istart if ( iend < istart ) iend = len_trim ( line ) isp = isp + 1 species ( isp ) = trim ( line ( istart : iend )) end do nspecies = isp if ( any ( to_number ( species (: nspecies )) == 0 )) then call fatal_error ( error , 'unknown atom type present' ) return end if do iatom = 1 , natoms call next_line ( unit , line , stat ) read ( line , * , iostat = stat ) dummy , isp , coord if ( stat /= 0 ) then call fatal_error ( error , 'could not read coordinates from file' ) return end if sym ( iatom ) = species ( isp ) if ( cartesian ) then xyz (:, iatom ) = coord * aatoau else abc (:, iatom ) = coord end if end do if ( periodic ) then call next_line ( unit , line , stat ) if ( stat /= 0 ) then call fatal_error ( error , 'missing lattice information' ) return end if do ilat = 1 , 3 call next_line ( unit , line , stat ) read ( line , * , iostat = stat ) coord if ( stat /= 0 ) then call fatal_error ( error , 'could not read lattice from file' ) return end if lattice (:, ilat ) = coord * aatoau end do if (. not . cartesian ) then xyz = matmul ( lattice , abc ) end if info = structure_info ( cartesian = cartesian ) call new ( mol , sym , xyz , lattice = lattice , info = info ) else call new ( mol , sym , xyz ) end if contains subroutine next_line ( unit , line , stat ) integer , intent ( in ) :: unit character ( len = :), allocatable , intent ( out ) :: line integer , intent ( out ) :: stat integer :: ihash stat = 0 do while ( stat == 0 ) call getline ( unit , line , stat ) ihash = index ( line , '#' ) if ( ihash > 0 ) line = line (: ihash - 1 ) if ( len_trim ( line ) > 0 ) exit end do line = trim ( adjustl ( line )) end subroutine next_line end subroutine read_genformat","tags":"","loc":"proc/read_genformat.html"},{"title":"read_molfile – MCTC-library","text":"public subroutine read_molfile(mol, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: mol Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Contents Source Code read_molfile Source Code subroutine read_molfile ( mol , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: mol !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error character ( len = :), allocatable :: line character ( len = :), allocatable :: name integer :: i , iatom , jatom , ibond , btype , atomtype integer :: stat , length , charge ( 2 , 15 ) integer :: number_of_atoms , number_of_bonds , number_of_atom_lists , & & chiral_flag , number_of_stext_entries , i999 integer :: list4 ( 4 ), list12 ( 12 ) real ( wp ) :: x , y , z character ( len = 2 ) :: sdf_dim character ( len = 3 ) :: symbol character ( len = 5 ) :: v2000 integer , parameter :: ccc_to_charge ( 0 : 7 ) = [ 0 , + 3 , + 2 , + 1 , 0 , - 1 , - 2 , - 3 ] logical :: two_dim character ( len = symbol_length ), allocatable :: sym (:) type ( sdf_data ), allocatable :: sdf (:) type ( structure_info ) :: info real ( wp ), allocatable :: xyz (:, :) two_dim = . false . call getline ( unit , name , stat ) call getline ( unit , line , stat ) read ( line , '(20x, a2)' , iostat = stat ) sdf_dim if ( stat == 0 ) then two_dim = sdf_dim == '2D' . or . sdf_dim == '2d' end if call getline ( unit , line , stat ) call getline ( unit , line , stat ) read ( line , '(3i3, 3x, 2i3, 12x, i3, 1x, a5)' , iostat = stat ) & & number_of_atoms , number_of_bonds , number_of_atom_lists , & & chiral_flag , number_of_stext_entries , i999 , v2000 if ( stat /= 0 ) then call fatal_error ( error , \"Cannot read header of molfile\" ) return end if allocate ( sdf ( number_of_atoms )) allocate ( xyz ( 3 , number_of_atoms )) allocate ( sym ( number_of_atoms )) do iatom = 1 , number_of_atoms call getline ( unit , line , stat ) read ( line , '(3f10.4, 1x, a3, i2, 11i3)' , iostat = stat ) & & x , y , z , symbol , list12 if ( stat /= 0 ) then call fatal_error ( error , \"Cannot read coordinates from connection table\" ) return end if atomtype = to_number ( symbol ) if ( atomtype == 0 ) then call fatal_error ( error , \"Unknown atom type '\" // trim ( symbol ) // \"' in connection table\" ) return end if xyz (:, iatom ) = [ x , y , z ] * aatoau sym ( iatom ) = trim ( symbol ) sdf ( iatom )% isotope = list12 ( 1 ) sdf ( iatom )% charge = ccc_to_charge ( list12 ( 2 )) ! drop doublet radical sdf ( iatom )% hydrogens = list12 ( 4 ) sdf ( iatom )% valence = list12 ( 6 ) end do !call mol%bonds%allocate(size=number_of_bonds, order=3) do ibond = 1 , number_of_bonds call getline ( unit , line , stat ) read ( line , '(7i3)' , iostat = stat ) & & iatom , jatom , btype , list4 if ( stat /= 0 ) then call fatal_error ( error , \"Cannot read topology from connection table\" ) return end if !call mol%bonds%push_back([iatom, jatom, btype]) end do do while ( stat == 0 ) call getline ( unit , line , stat ) if ( index ( line , 'M  END' ) == 1 ) exit if ( index ( line , 'M  CHG' ) == 1 ) then read ( line ( 7 : 9 ), * ) length read ( line ( 10 :), '(*(1x, i3, 1x, i3))' ) ( charge (:, i ), i = 1 , length ) do i = 1 , length sdf ( charge ( 1 , i ))% charge = charge ( 2 , i ) end do end if end do if ( stat /= 0 ) then call fatal_error ( error , \"Cannot read connection table\" ) return end if info = structure_info ( two_dimensional = two_dim , & & missing_hydrogen = any ( sdf % hydrogens > 1 )) call new ( mol , sym , xyz , charge = real ( sum ( sdf % charge ), wp ), info = info ) call move_alloc ( sdf , mol % sdf ) !if (len(name) > 0) mol%name = name end subroutine read_molfile","tags":"","loc":"proc/read_molfile.html"},{"title":"read_sdf – MCTC-library","text":"public subroutine read_sdf(mol, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: mol Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Contents Source Code read_sdf Source Code subroutine read_sdf ( mol , unit , error ) !> Instance of the molecular structure data type ( structure_type ), intent ( out ) :: mol !> File handle integer , intent ( in ) :: unit !> Error handling type ( error_type ), allocatable , intent ( out ) :: error character ( len = :), allocatable :: line integer :: stat call read_molfile ( mol , unit , error ) if ( allocated ( error )) return stat = 0 do while ( stat == 0 ) call getline ( unit , line , stat ) if ( index ( line , '' ) == 1 ) exit end do if ( stat /= 0 ) then call fatal_error ( error , \"Failed while reading SDF key-value pairs\" ) return end if end subroutine read_sdf","tags":"","loc":"proc/read_sdf.html"},{"title":"get_argument – MCTC-library","text":"subroutine get_argument(idx, arg) Obtain the command line argument at a given index Arguments Type Intent Optional Attributes Name integer, intent(in) :: idx Index of command line argument, range [0:command_argument_count()] character(len=:), intent(out), allocatable :: arg Command line argument Contents Source Code get_argument Source Code subroutine get_argument ( idx , arg ) !> Index of command line argument, range [0:command_argument_count()] integer , intent ( in ) :: idx !> Command line argument character ( len = :), allocatable , intent ( out ) :: arg integer :: length , stat call get_command_argument ( idx , length = length , status = stat ) if ( stat /= 0 ) then return endif allocate ( character ( len = length ) :: arg , stat = stat ) if ( stat /= 0 ) then return endif if ( length > 0 ) then call get_command_argument ( idx , arg , status = stat ) if ( stat /= 0 ) then deallocate ( arg ) return end if end if end subroutine get_argument","tags":"","loc":"proc/get_argument.html"},{"title":"get_arguments – MCTC-library","text":"subroutine get_arguments(input, input_format, output, output_format, normalize, error) Arguments Type Intent Optional Attributes Name character(len=:), allocatable :: input Input file name integer, intent(out), allocatable :: input_format Input file format character(len=:), allocatable :: output Output file name integer, intent(out), allocatable :: output_format Output file format logical, intent(out) :: normalize Normalize element symbols type(error_type), intent(out), allocatable :: error Error handling Contents Source Code get_arguments Source Code subroutine get_arguments ( input , input_format , output , output_format , normalize , & & error ) !> Input file name character ( len = :), allocatable :: input !> Input file format integer , allocatable , intent ( out ) :: input_format !> Output file name character ( len = :), allocatable :: output !> Output file format integer , allocatable , intent ( out ) :: output_format !> Normalize element symbols logical , intent ( out ) :: normalize !> Error handling type ( error_type ), allocatable , intent ( out ) :: error integer :: iarg , narg character ( len = :), allocatable :: arg normalize = . false . iarg = 0 narg = command_argument_count () do while ( iarg < narg ) iarg = iarg + 1 call get_argument ( iarg , arg ) select case ( arg ) case ( \"--help\" ) call help ( output_unit ) stop case ( \"--version\" ) call version ( output_unit ) stop case default if (. not . allocated ( input )) then call move_alloc ( arg , input ) cycle end if if (. not . allocated ( output )) then call move_alloc ( arg , output ) cycle end if call fatal_error ( error , \"Too many positional arguments present\" ) exit case ( \"-i\" , \"--input\" ) iarg = iarg + 1 call get_argument ( iarg , arg ) if (. not . allocated ( arg )) then call fatal_error ( error , \"Missing argument for input format\" ) exit end if input_format = get_filetype ( \".\" // arg ) case ( \"-o\" , \"--output\" ) iarg = iarg + 1 call get_argument ( iarg , arg ) if (. not . allocated ( arg )) then call fatal_error ( error , \"Missing argument for output format\" ) exit end if output_format = get_filetype ( \".\" // arg ) case ( \"--normalize\" ) normalize = . true . end select end do if (. not .( allocated ( input ). and .( allocated ( output )))) then if (. not . allocated ( error )) then call help ( output_unit ) error stop end if end if end subroutine get_arguments","tags":"","loc":"proc/get_arguments.html"},{"title":"help – MCTC-library","text":"subroutine help(unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Contents Source Code help Source Code subroutine help ( unit ) integer , intent ( in ) :: unit write ( unit , '(a, *(1x, a))' ) & \"Usage: \" // prog_name // \" [options] <input> <output>\" write ( unit , '(a)' ) & \"\" , & \"Read structure from input file and writes it to output file.\" , & \"The format is determined by the file extension or the format hint\" , & \"\" write ( unit , '(2x, a, t25, a)' ) & \"-i, --input <format>\" , \"Hint for the format of the input file\" , & \"-o, --output <format>\" , \"Hint for the format of the output file\" , & \"--normalize\" , \"Normalize all element symbols to capitalized format\" , & \"--version\" , \"Print program version and exit\" , & \"--help\" , \"Show this help message\" write ( unit , '(a)' ) end subroutine help","tags":"","loc":"proc/help.html"},{"title":"version – MCTC-library","text":"subroutine version(unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Contents Source Code version Source Code subroutine version ( unit ) integer , intent ( in ) :: unit character ( len = :), allocatable :: version_string call get_mctc_version ( string = version_string ) write ( unit , '(a, *(1x, a))' ) & & prog_name , \"version\" , version_string end subroutine version","tags":"","loc":"proc/version.html"},{"title":"mctc_io – MCTC-library","text":"Uses mctc_io_filetype mctc_io_read mctc_io_structure mctc_io_write Contents None","tags":"","loc":"module/mctc_io.html"},{"title":"mctc_env – MCTC-library","text":"Public API reexport of environment library Uses mctc_env_accuracy mctc_env_error Contents None","tags":"","loc":"module/mctc_env.html"},{"title":"mctc_version – MCTC-library","text":"Contents Variables mctc_version_compact mctc_version_string Subroutines get_mctc_version Variables Type Visibility Attributes Name Initial integer, public, parameter :: mctc_version_compact (3) = [0, 1, 1] Numeric representation of the mctc-lib version character(len=*), public, parameter :: mctc_version_string = \"0.1.1\" String representation of the mctc-lib version Subroutines public subroutine get_mctc_version (major, minor, patch, string) Getter function to retrieve mctc-lib version Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: major Major version number of the mctc-lib version integer, intent(out), optional :: minor Minor version number of the mctc-lib version integer, intent(out), optional :: patch Patch version number of the mctc-lib version character(len=:), intent(out), optional allocatable :: string String representation of the mctc-lib version","tags":"","loc":"module/mctc_version.html"},{"title":"mctc_env_accuracy – MCTC-library","text":"Numerical storage size parameters for real and integer values Contents Variables dp i1 i2 i4 i8 sp wp Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = selected_real_kind(15) Double precision real numbers integer, public, parameter :: i1 = selected_int_kind(2) Char length for integers integer, public, parameter :: i2 = selected_int_kind(4) Short length for integers integer, public, parameter :: i4 = selected_int_kind(9) Length of default integers integer, public, parameter :: i8 = selected_int_kind(18) Long length for integers integer, public, parameter :: sp = selected_real_kind(6) Single precision real numbers integer, public, parameter :: wp = dp Wanted precision","tags":"","loc":"module/mctc_env_accuracy.html"},{"title":"mctc_env_testing – MCTC-library","text":"Uses mctc_env_error mctc_env_accuracy Contents Interfaces check Derived Types testsuite_type unittest_type Functions new_testsuite new_unittest select_suite select_test Subroutines run_selected run_testsuite test_failed Interfaces public interface check private subroutine check_stat(error, stat, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling integer, intent(in) :: stat Status of operation character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private subroutine check_float_sp(error, actual, expected, message, more, thr, rel) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling real(kind=sp), intent(in) :: actual Found floating point value real(kind=sp), intent(in) :: expected Expected floating point value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message real(kind=sp), intent(in), optional :: thr Allowed threshold for matching floating point values logical, intent(in), optional :: rel Check for relative errors instead private subroutine check_float_dp(error, actual, expected, message, more, thr, rel) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling real(kind=dp), intent(in) :: actual Found floating point value real(kind=dp), intent(in) :: expected Expected floating point value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message real(kind=dp), intent(in), optional :: thr Allowed threshold for matching floating point values logical, intent(in), optional :: rel Check for relative errors instead private subroutine check_int_i1(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling integer(kind=i1), intent(in) :: actual Found integer value integer(kind=i1), intent(in) :: expected Expected integer value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private subroutine check_int_i2(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling integer(kind=i2), intent(in) :: actual Found integer value integer(kind=i2), intent(in) :: expected Expected integer value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private subroutine check_int_i4(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling integer(kind=i4), intent(in) :: actual Found integer value integer(kind=i4), intent(in) :: expected Expected integer value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private subroutine check_int_i8(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling integer(kind=i8), intent(in) :: actual Found integer value integer(kind=i8), intent(in) :: expected Expected integer value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private subroutine check_bool(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling logical, intent(in) :: actual Found boolean value logical, intent(in) :: expected Expected boolean value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message private subroutine check_string(error, actual, expected, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling character(len=*), intent(in) :: actual Found boolean value character(len=*), intent(in) :: expected Expected boolean value character(len=*), intent(in), optional :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message Derived Types type, public :: testsuite_type Collection of unit tests Components Type Visibility Attributes Name Initial procedure(collect_interface), public, pointer, nopass :: collect => null() Entry point of the test character(len=:), public, allocatable :: name Name of the testsuite type, public :: unittest_type Declaration of a unit test Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name Name of the test logical, public :: should_fail = .false. Whether test is supposed to fail procedure(test_interface), public, pointer, nopass :: test => null() Entry point of the test Functions public function new_testsuite (name, collect) result(self) Register a new testsuite Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of the testsuite procedure(collect_interface) :: collect Entry point to collect tests Return Value type( testsuite_type ) Newly registered testsuite public function new_unittest (name, test, should_fail) result(self) Register a new unit test Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Name of the test procedure(test_interface) :: test Entry point for the test logical, intent(in), optional :: should_fail Whether test is supposed to error or not Return Value type( unittest_type ) Newly registered test public function select_suite (suites, name) result(pos) Select a test suite from all available suites Arguments Type Intent Optional Attributes Name type( testsuite_type ) :: suites (:) Available test suites character(len=*), intent(in) :: name Name identifying the test suite Return Value integer Selected test suite public function select_test (tests, name) result(pos) Select a unit test from all available tests Arguments Type Intent Optional Attributes Name type( unittest_type ) :: tests (:) Available unit tests character(len=*), intent(in) :: name Name identifying the test suite Return Value integer Selected test suite Subroutines public subroutine run_selected (collect, name, unit, stat) Driver for selective testing Arguments Type Intent Optional Attributes Name procedure(collect_interface) :: collect Collect tests character(len=*), intent(in) :: name Name of the selected test integer, intent(in) :: unit Unit for IO integer, intent(inout) :: stat Number of failed tests public subroutine run_testsuite (collect, unit, stat) Driver for testsuite Arguments Type Intent Optional Attributes Name procedure(collect_interface) :: collect Collect tests integer, intent(in) :: unit Unit for IO integer, intent(inout) :: stat Number of failed tests public subroutine test_failed (error, message, more) Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Error handling character(len=*), intent(in) :: message A detailed message describing the error character(len=*), intent(in), optional :: more Another line of error message","tags":"","loc":"module/mctc_env_testing.html"},{"title":"mctc_env_error – MCTC-library","text":"Central registry for error codes Contents Variables mctc_stat Derived Types error_type Subroutines fatal_error Variables Type Visibility Attributes Name Initial type(enum_stat), public, parameter :: mctc_stat = enum_stat() Actual enumerator for return states Derived Types type, public :: error_type Error message Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: message Payload of the error integer, public :: stat Error code Subroutines public subroutine fatal_error (error, message, stat) A fatal error is encountered Arguments Type Intent Optional Attributes Name type( error_type ), intent(out), allocatable :: error Instance of the error character(len=*), intent(in), optional :: message A detailed message describing the error and (optionally) offering advice integer, intent(in), optional :: stat Overwrite of the error code","tags":"","loc":"module/mctc_env_error.html"},{"title":"mctc_io_write – MCTC-library","text":"Uses mctc_env_error mctc_io_filetype mctc_io_write_ctfile mctc_io_write_gaussian mctc_io_write_genformat mctc_io_write_pdb mctc_io_write_turbomole mctc_io_write_vasp mctc_io_write_xyz mctc_io_structure Contents Interfaces write_structure Interfaces public interface write_structure private subroutine write_structure_to_file(self, file, error, format) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self Instance of the molecular structure data character(len=*), intent(in) :: file Name of the file to read type( error_type ), intent(out), allocatable :: error Error handling integer, intent(in), optional :: format File type format hint private subroutine write_structure_to_unit(self, unit, ftype, error) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle integer, intent(in) :: ftype File type to read type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/mctc_io_write.html"},{"title":"mctc_io_resize – MCTC-library","text":"Reallocation implementation for resizing arrays Uses mctc_env_accuracy Contents Interfaces resize Interfaces public interface resize Overloaded resize interface private pure subroutine resize_char(var, n) Reallocate list of characters Arguments Type Intent Optional Attributes Name character(len=*), intent(inout), allocatable :: var (:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size private pure subroutine resize_int(var, n) Reallocate list of integers Arguments Type Intent Optional Attributes Name integer, intent(inout), allocatable :: var (:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size private pure subroutine resize_real(var, n) Reallocate list of reals Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), allocatable :: var (:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size private pure subroutine resize_real_2d(var, n) Reallocate list of reals Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), allocatable :: var (:,:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size","tags":"","loc":"module/mctc_io_resize.html"},{"title":"mctc_io_constants – MCTC-library","text":"Numerical constants Uses mctc_env_accuracy Contents Variables codata pi Variables Type Visibility Attributes Name Initial type(enum_codata), public, parameter :: codata = enum_codata() Actual collection of natural constants real(kind=wp), public, parameter :: pi = 3.1415926535897932384626433832795029_wp Ratio between a circles diameter and its circumfence","tags":"","loc":"module/mctc_io_constants.html"},{"title":"mctc_io_math – MCTC-library","text":"Simple algebraic functions Uses mctc_env_accuracy mctc_io_constants Contents Functions crossprod matdet_3x3 matinv_3x3 Subroutines eigval_3x3 eigvec_3x3 Functions public pure function crossprod (a, b) result(c) Implements the cross/vector product between two 3D vectors Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (3) First vector real(kind=wp), intent(in) :: b (3) Second vector Return Value real(kind=wp)\n  (3) Orthogonal vector public pure function matdet_3x3 (a) result(det) Determinat of 3×3 matrix Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (3,3) Matrix Return Value real(kind=wp) Determinant public pure function matinv_3x3 (a) result(b) Performs a direct calculation of the inverse of a 3×3 matrix. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (3,3) Matrix Return Value real(kind=wp)\n  (3,3) Inverse matrix Subroutines public pure subroutine eigval_3x3 (a, w) Calculates eigenvalues based on the trigonometric solution of A = pB + qI Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (3,3) The symmetric input matrix real(kind=wp), intent(out) :: w (3) Contains eigenvalues on exit public pure subroutine eigvec_3x3 (a, w, q) Calculates eigenvector using an analytical method based on vector cross Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: a (3,3) real(kind=wp), intent(out) :: w (3) real(kind=wp), intent(out) :: q (3,3)","tags":"","loc":"module/mctc_io_math.html"},{"title":"mctc_io_filetype – MCTC-library","text":"File type support Contents Variables filetype Functions get_filetype Variables Type Visibility Attributes Name Initial type(enum_filetype), public, parameter :: filetype = enum_filetype() File type enumerator Functions public elemental function get_filetype (file) result(ftype) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file Name of the file Return Value integer File type from extension","tags":"","loc":"module/mctc_io_filetype.html"},{"title":"mctc_io_utils – MCTC-library","text":"Contents Subroutines getline Subroutines public subroutine getline (unit, line, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Formatted IO unit character(len=:), intent(out), allocatable :: line Line to read integer, intent(out) :: iostat Status of operation character(len=:), optional allocatable :: iomsg Error message","tags":"","loc":"module/mctc_io_utils.html"},{"title":"mctc_io_read – MCTC-library","text":"Uses mctc_env_error mctc_io_filetype mctc_io_read_ctfile mctc_io_read_gaussian mctc_io_read_genformat mctc_io_read_pdb mctc_io_read_turbomole mctc_io_read_vasp mctc_io_read_xyz mctc_io_structure Contents Interfaces read_structure Abstract Interfaces structure_reader Subroutines get_structure_reader Interfaces public interface read_structure private subroutine read_structure_from_file(self, file, error, format) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data character(len=*), intent(in) :: file Name of the file to read type( error_type ), intent(out), allocatable :: error Error handling integer, intent(in), optional :: format File type format hint private subroutine read_structure_from_unit(self, unit, ftype, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle integer, intent(in) :: ftype File type to read type( error_type ), intent(out), allocatable :: error Error handling Abstract Interfaces abstract interface public subroutine structure_reader(self, unit, error) Read molecular structure data from formatted unit Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling Subroutines public subroutine get_structure_reader (reader, ftype) Retrieve reader for corresponding file type Arguments Type Intent Optional Attributes Name procedure( structure_reader ), intent(out), pointer :: reader Reader for the specified file type integer, intent(in) :: ftype File type to read","tags":"","loc":"module/mctc_io_read.html"},{"title":"mctc_io_symbols – MCTC-library","text":"Handle conversion between element symbols and atomic numbers Uses mctc_io_resize Contents Variables symbol_length Interfaces get_identity Functions to_lcsymbol to_number to_symbol Subroutines collect_identical number_to_lcsymbol number_to_symbol symbol_to_number Variables Type Visibility Attributes Name Initial integer, public, parameter :: symbol_length = 4 Maximum allowed length of element symbols Interfaces public interface get_identity Get chemical identity private pure subroutine get_identity_number(nid, identity, number) Get chemical identity from a list of atomic numbers Arguments Type Intent Optional Attributes Name integer, intent(out) :: nid Number of unique species integer, intent(out) :: identity (:) Chemical identity integer, intent(in) :: number (:) Ordinal numbers private pure subroutine get_identity_symbol(nid, identity, symbol) Get chemical identity from a list of element symbols Arguments Type Intent Optional Attributes Name integer, intent(out) :: nid Number of unique species integer, intent(out) :: identity (:) Chemical identity character(len=symbol_length), intent(in) :: symbol (:) Element symbols Functions public elemental function to_lcsymbol (number) result(symbol) Convert atomic number to element symbol Arguments Type Intent Optional Attributes Name integer, intent(in) :: number Atomic number Return Value character(len=2) Element symbol public elemental function to_number (symbol) result(number) Convert element symbol to atomic number Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: symbol Element symbol Return Value integer Atomic number public elemental function to_symbol (number) result(symbol) Convert atomic number to element symbol Arguments Type Intent Optional Attributes Name integer, intent(in) :: number Atomic number Return Value character(len=2) Element symbol Subroutines public pure subroutine collect_identical (identity, mapping) Establish a mapping between unique atom types and species Arguments Type Intent Optional Attributes Name integer, intent(in) :: identity (:) Chemical identity integer, intent(out) :: mapping (:) Mapping from unique atoms public elemental subroutine number_to_lcsymbol (symbol, number) Convert atomic number to element symbol Arguments Type Intent Optional Attributes Name character(len=2), intent(out) :: symbol Element symbol integer, intent(in) :: number Atomic number public elemental subroutine number_to_symbol (symbol, number) Convert atomic number to element symbol Arguments Type Intent Optional Attributes Name character(len=2), intent(out) :: symbol Element symbol integer, intent(in) :: number Atomic number public elemental subroutine symbol_to_number (number, symbol) Convert element symbol to atomic number Arguments Type Intent Optional Attributes Name integer, intent(out) :: number Atomic number character(len=*), intent(in) :: symbol Element symbol","tags":"","loc":"module/mctc_io_symbols.html"},{"title":"mctc_io_structure – MCTC-library","text":"Basic structure representation of the system of interest Uses mctc_env_accuracy mctc_io_symbols mctc_io_structure_info Contents Interfaces new Derived Types structure_type Subroutines new_structure Interfaces public interface new public subroutine new_structure (self, num, sym, xyz, charge, uhf, lattice, periodic, info) Constructor for structure representations Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the structure representation integer, intent(in) :: num (:) Atomic numbers character(len=*), intent(in) :: sym (:) Element symbols real(kind=wp), intent(in) :: xyz (:,:) Cartesian coordinates real(kind=wp), intent(in), optional :: charge Total charge integer, intent(in), optional :: uhf Number of unpaired electrons real(kind=wp), intent(in), optional :: lattice (:,:) Lattice parameters logical, intent(in), optional :: periodic (:) Periodic directions type( structure_info ), intent(in), optional :: info Vendor specific structure information private subroutine new_structure_num(self, num, xyz, charge, uhf, lattice, periodic, info) Simplified constructor for structure representations Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the structure representation integer, intent(in) :: num (:) Atomic numbers real(kind=wp), intent(in) :: xyz (:,:) Cartesian coordinates real(kind=wp), intent(in), optional :: charge Total charge integer, intent(in), optional :: uhf Number of unpaired electrons real(kind=wp), intent(in), optional :: lattice (:,:) Lattice parameters logical, intent(in), optional :: periodic (:) Periodic directions type( structure_info ), intent(in), optional :: info Vendor specific structure information private subroutine new_structure_sym(self, sym, xyz, charge, uhf, lattice, periodic, info) Simplified constructor for structure representations Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the structure representation character(len=*), intent(in) :: sym (:) Element symbols real(kind=wp), intent(in) :: xyz (:,:) Cartesian coordinates real(kind=wp), intent(in), optional :: charge Total charge integer, intent(in), optional :: uhf Number of unpaired electrons real(kind=wp), intent(in), optional :: lattice (:,:) Lattice parameters logical, intent(in), optional :: periodic (:) Periodic directions type( structure_info ), intent(in), optional :: info Vendor specific structure information Derived Types type, public :: structure_type Structure representation Components Type Visibility Attributes Name Initial real(kind=wp), public :: charge = 0.0_wp Total charge integer, public, allocatable :: id (:) Species identifier type( structure_info ), public :: info = structure_info() Vendor specific structure annotations real(kind=wp), public, allocatable :: lattice (:,:) Lattice parameters integer, public :: nat = 0 Number of atoms integer, public :: nid = 0 Number of unique species integer, public, allocatable :: num (:) Atomic number for each species type( pdb_data ), public, allocatable :: pdb (:) PDB atomic data annotations logical, public, allocatable :: periodic (:) Periodic directions type( sdf_data ), public, allocatable :: sdf (:) SDF atomic data annotations character(len=symbol_length), public, allocatable :: sym (:) Element symbol for each species integer, public :: uhf = 0 Number of unpaired electrons real(kind=wp), public, allocatable :: xyz (:,:) Cartesian coordinates, in Bohr Subroutines public subroutine new_structure (self, num, sym, xyz, charge, uhf, lattice, periodic, info) Constructor for structure representations Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the structure representation integer, intent(in) :: num (:) Atomic numbers character(len=*), intent(in) :: sym (:) Element symbols real(kind=wp), intent(in) :: xyz (:,:) Cartesian coordinates real(kind=wp), intent(in), optional :: charge Total charge integer, intent(in), optional :: uhf Number of unpaired electrons real(kind=wp), intent(in), optional :: lattice (:,:) Lattice parameters logical, intent(in), optional :: periodic (:) Periodic directions type( structure_info ), intent(in), optional :: info Vendor specific structure information","tags":"","loc":"module/mctc_io_structure.html"},{"title":"mctc_io_convert – MCTC-library","text":"Conversion factors Uses mctc_env_accuracy mctc_io_constants Contents Variables aatoau autoaa autoc autoeV autogmol autokcal autokg autokj autonm autorcm caltoj ctoau evtoau gmoltoau gmoltokg jtocal kcaltoau kgtoau kgtogmol kjtoau nmtoau rcmtoau Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: aatoau = 1.0_wp/autoaa Conversion factor from Ångström to bohr real(kind=wp), public, parameter :: autoaa = bohr*1e10_wp Conversion factor from bohr to Ångström real(kind=wp), public, parameter :: autoc = codata%e Coulomb to atomic charge units real(kind=wp), public, parameter :: autoeV = hartree/codata%e Conversion factor from hartree to electron volts real(kind=wp), public, parameter :: autogmol = codata%me*codata%na*1e+3_wp Molecular mass per mole (g/mol) to electron mass (a.u.) real(kind=wp), public, parameter :: autokcal = autokJ*Jtocal Conversion from hartree to kcal/mol real(kind=wp), public, parameter :: autokg = codata%me Conversion from electron mass (a.u.) to kg real(kind=wp), public, parameter :: autokj = hartree*codata%na*1e-3_wp Conversion from hartree to kJ/mol real(kind=wp), public, parameter :: autonm = codata%h*codata%c/hartree*1e+9_wp Conversion from hartree to nanometers (wavelength) real(kind=wp), public, parameter :: autorcm = hartree/(codata%h*codata%c)*1e-2_wp Conversion from hartree to reciprocal centimeters real(kind=wp), public, parameter :: caltoj = 4.184_wp Coversion factor between calorine and joule real(kind=wp), public, parameter :: ctoau = 1.0_wp/autoc Atomic charge units to Coulomb real(kind=wp), public, parameter :: evtoau = 1.0_wp/autoev Conversion factor from electron volts to hartree real(kind=wp), public, parameter :: gmoltoau = 1.0_wp/autogmol Electron mass (a.u.) to molecular mass per mole (g/mol) real(kind=wp), public, parameter :: gmoltokg = gmoltoau*autokg Molecular mass per mole (g/mol) to kg real(kind=wp), public, parameter :: jtocal = 1.0_wp/caltoj Coversion factor between joule and calorine real(kind=wp), public, parameter :: kcaltoau = 1.0_wp/autokcal Conversion from kcal/mol to hartree real(kind=wp), public, parameter :: kgtoau = 1.0_wp/autokg Conversion from kg to electron mass (a.u.) real(kind=wp), public, parameter :: kgtogmol = 1.0_wp/gmoltokg kg to molecular mass per mole (g/mol) real(kind=wp), public, parameter :: kjtoau = 1.0_wp/autokj Conversion from kJ/mol to hartree real(kind=wp), public, parameter :: nmtoau = 1.0_wp/autonm Conversion from nanometers (wavelength) to hartree real(kind=wp), public, parameter :: rcmtoau = 1.0_wp/autorcm Conversion from reciprocal centimeters to hartree","tags":"","loc":"module/mctc_io_convert.html"},{"title":"mctc_io_write_gaussian – MCTC-library","text":"Uses mctc_env_accuracy mctc_io_structure Contents Subroutines write_gaussian_external Subroutines public subroutine write_gaussian_external (mol, unit) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(in) :: mol integer, intent(in) :: unit","tags":"","loc":"module/mctc_io_write_gaussian.html"},{"title":"mctc_io_write_pdb – MCTC-library","text":"Uses mctc_env_accuracy mctc_io_convert mctc_io_structure Contents Subroutines write_pdb Subroutines public subroutine write_pdb (mol, unit, number) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(in) :: mol integer, intent(in) :: unit integer, intent(in), optional :: number","tags":"","loc":"module/mctc_io_write_pdb.html"},{"title":"mctc_io_write_xyz – MCTC-library","text":"Uses mctc_io_convert mctc_io_structure Contents Subroutines write_xyz Subroutines public subroutine write_xyz (mol, unit, comment_line) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: mol integer, intent(in) :: unit character(len=*), intent(in), optional :: comment_line","tags":"","loc":"module/mctc_io_write_xyz.html"},{"title":"mctc_io_write_vasp – MCTC-library","text":"Uses mctc_env_accuracy mctc_io_convert mctc_io_math mctc_io_structure Contents Subroutines write_vasp Subroutines public subroutine write_vasp (mol, unit, comment_line) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: mol integer, intent(in) :: unit character(len=*), intent(in), optional :: comment_line","tags":"","loc":"module/mctc_io_write_vasp.html"},{"title":"mctc_io_write_turbomole – MCTC-library","text":"Uses mctc_env_accuracy mctc_io_structure Contents Subroutines write_coord Subroutines public subroutine write_coord (mol, unit) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: mol integer, intent(in) :: unit","tags":"","loc":"module/mctc_io_write_turbomole.html"},{"title":"mctc_io_write_genformat – MCTC-library","text":"Uses mctc_env_accuracy mctc_io_convert mctc_io_math mctc_io_symbols mctc_io_structure Contents Subroutines write_genformat Subroutines public subroutine write_genformat (mol, unit) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: mol integer, intent(in) :: unit","tags":"","loc":"module/mctc_io_write_genformat.html"},{"title":"mctc_io_write_ctfile – MCTC-library","text":"Uses mctc_env_accuracy mctc_io_convert mctc_io_structure Contents Subroutines write_molfile write_sdf Subroutines public subroutine write_molfile (self, unit, comment_line) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in), optional :: comment_line public subroutine write_sdf (self, unit, energy, gnorm) Arguments Type Intent Optional Attributes Name class( structure_type ), intent(in) :: self integer, intent(in) :: unit real(kind=wp), intent(in), optional :: energy real(kind=wp), intent(in), optional :: gnorm","tags":"","loc":"module/mctc_io_write_ctfile.html"},{"title":"mctc_io_structure_info – MCTC-library","text":"Uses mctc_env_accuracy Contents Interfaces resize Derived Types pdb_data sdf_data structure_info Interfaces public interface resize private subroutine resize_pdb_data(var, n) Arguments Type Intent Optional Attributes Name type( pdb_data ), intent(inout), allocatable :: var (:) integer, intent(in), optional :: n Derived Types type, public :: pdb_data Atomic pdb data type. Read more… Components Type Visibility Attributes Name Initial character(len=1), public :: chains = ' ' integer, public :: charge = 0 character(len=1), public :: code = ' ' logical, public :: het = .false. character(len=1), public :: loc = ' ' character(len=4), public :: name = ' ' character(len=3), public :: residue = ' ' integer, public :: residue_number = 0 character(len=4), public :: segid = ' ' type, public :: sdf_data SDF atomic data. Read more… Components Type Visibility Attributes Name Initial integer, public :: charge = 0 c field integer, public :: hydrogens = 0 h field integer, public :: isotope = 0 d field integer, public :: valence = 0 v field type, public :: structure_info structure input info Read more… Components Type Visibility Attributes Name Initial logical, public :: angs_coord = .false. Unit of the atomic coordinates should be in Angstrom if possible logical, public :: angs_lattice = .false. Unit of the lattice vectors should be in Angstrom if possible logical, public :: cartesian = .true. Periodic coordinates should use preferrably cartesian coordinates logical, public :: lattice = .true. Lattice information should use preferrably lattice vectors logical, public :: missing_hydrogen = .false. SDF hydrogen query present or PDB without hydrogen atoms found real(kind=wp), public :: scale = 1.0_wp Vasp coordinate scaling information logical, public :: selective = .false. Vasp selective dynamics keyword is present logical, public :: two_dimensional = .false. SDF 2D structure present","tags":"","loc":"module/mctc_io_structure_info.html"},{"title":"mctc_io_read_gaussian – MCTC-library","text":"Uses mctc_env_accuracy mctc_env_error mctc_io_structure Contents Subroutines read_gaussian_external Subroutines public subroutine read_gaussian_external (self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/mctc_io_read_gaussian.html"},{"title":"mctc_io_read_pdb – MCTC-library","text":"Uses mctc_env_accuracy mctc_env_error mctc_io_convert mctc_io_resize mctc_io_symbols mctc_io_structure mctc_io_structure_info mctc_io_utils Contents Subroutines read_pdb Subroutines public subroutine read_pdb (self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/mctc_io_read_pdb.html"},{"title":"mctc_io_read_xyz – MCTC-library","text":"Uses mctc_env_accuracy mctc_env_error mctc_io_convert mctc_io_structure mctc_io_symbols mctc_io_utils Contents Subroutines read_xyz Subroutines public subroutine read_xyz (self, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: self Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/mctc_io_read_xyz.html"},{"title":"mctc_io_read_vasp – MCTC-library","text":"Uses mctc_env_accuracy mctc_env_error mctc_io_convert mctc_io_resize mctc_io_structure mctc_io_structure_info mctc_io_symbols mctc_io_utils Contents Subroutines read_vasp Subroutines public subroutine read_vasp (mol, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: mol Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/mctc_io_read_vasp.html"},{"title":"mctc_io_read_turbomole – MCTC-library","text":"Uses mctc_env_accuracy mctc_env_error mctc_io_constants mctc_io_convert mctc_io_resize mctc_io_structure mctc_io_structure_info mctc_io_symbols mctc_io_utils Contents Subroutines read_coord Subroutines public subroutine read_coord (mol, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: mol Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/mctc_io_read_turbomole.html"},{"title":"mctc_io_read_genformat – MCTC-library","text":"Uses mctc_env_accuracy mctc_env_error mctc_io_convert mctc_io_structure mctc_io_structure_info mctc_io_symbols mctc_io_utils Contents Subroutines read_genformat Subroutines public subroutine read_genformat (mol, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: mol Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/mctc_io_read_genformat.html"},{"title":"mctc_io_read_ctfile – MCTC-library","text":"Uses mctc_env_accuracy mctc_env_error mctc_io_convert mctc_io_structure mctc_io_structure_info mctc_io_symbols mctc_io_utils Contents Subroutines read_molfile read_sdf Subroutines public subroutine read_molfile (mol, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: mol Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling public subroutine read_sdf (mol, unit, error) Arguments Type Intent Optional Attributes Name type( structure_type ), intent(out) :: mol Instance of the molecular structure data integer, intent(in) :: unit File handle type( error_type ), intent(out), allocatable :: error Error handling","tags":"","loc":"module/mctc_io_read_ctfile.html"},{"title":"main – MCTC-library","text":"Uses iso_fortran_env mctc_env mctc_io mctc_io_symbols mctc_version Contents Variables error input input_format mol normalize output output_format prog_name Subroutines get_argument get_arguments help version Source Code main Variables Type Attributes Name Initial type(error_type), allocatable :: error character(len=:), allocatable :: input integer, allocatable :: input_format type( structure_type ) :: mol logical :: normalize character(len=:), allocatable :: output integer, allocatable :: output_format character(len=*), parameter :: prog_name = \"mctc-convert\" Subroutines subroutine get_argument (idx, arg) Obtain the command line argument at a given index Arguments Type Intent Optional Attributes Name integer, intent(in) :: idx Index of command line argument, range [0:command_argument_count()] character(len=:), intent(out), allocatable :: arg Command line argument subroutine get_arguments (input, input_format, output, output_format, normalize, error) Arguments Type Intent Optional Attributes Name character(len=:), allocatable :: input Input file name integer, intent(out), allocatable :: input_format Input file format character(len=:), allocatable :: output Output file name integer, intent(out), allocatable :: output_format Output file format logical, intent(out) :: normalize Normalize element symbols type(error_type), intent(out), allocatable :: error Error handling subroutine help (unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit subroutine version (unit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Source Code program main use , intrinsic :: iso_fortran_env , only : output_unit , error_unit , input_unit use mctc_env use mctc_io use mctc_io_symbols , only : to_symbol use mctc_version implicit none character ( len =* ), parameter :: prog_name = \"mctc-convert\" character ( len = :), allocatable :: input , output integer , allocatable :: input_format , output_format type ( structure_type ) :: mol type ( error_type ), allocatable :: error logical :: normalize call get_arguments ( input , input_format , output , output_format , normalize , error ) if ( allocated ( error )) then write ( error_unit , '(a)' ) error % message error stop end if if ( input == \"-\" ) then if (. not . allocated ( input_format )) input_format = filetype % xyz call read_structure ( mol , input_unit , input_format , error ) else call read_structure ( mol , input , error , input_format ) end if if ( allocated ( error )) then write ( error_unit , '(a)' ) error % message error stop end if if ( normalize ) then mol % sym = to_symbol ( mol % num ) end if if ( output == \"-\" ) then if (. not . allocated ( output_format )) output_format = filetype % xyz call write_structure ( mol , output_unit , output_format , error ) else call write_structure ( mol , output , error , output_format ) end if if ( allocated ( error )) then write ( error_unit , '(a)' ) error % message error stop end if contains subroutine help ( unit ) integer , intent ( in ) :: unit write ( unit , '(a, *(1x, a))' ) & \"Usage: \" // prog_name // \" [options] <input> <output>\" write ( unit , '(a)' ) & \"\" , & \"Read structure from input file and writes it to output file.\" , & \"The format is determined by the file extension or the format hint\" , & \"\" write ( unit , '(2x, a, t25, a)' ) & \"-i, --input <format>\" , \"Hint for the format of the input file\" , & \"-o, --output <format>\" , \"Hint for the format of the output file\" , & \"--normalize\" , \"Normalize all element symbols to capitalized format\" , & \"--version\" , \"Print program version and exit\" , & \"--help\" , \"Show this help message\" write ( unit , '(a)' ) end subroutine help subroutine version ( unit ) integer , intent ( in ) :: unit character ( len = :), allocatable :: version_string call get_mctc_version ( string = version_string ) write ( unit , '(a, *(1x, a))' ) & & prog_name , \"version\" , version_string end subroutine version !> Obtain the command line argument at a given index subroutine get_argument ( idx , arg ) !> Index of command line argument, range [0:command_argument_count()] integer , intent ( in ) :: idx !> Command line argument character ( len = :), allocatable , intent ( out ) :: arg integer :: length , stat call get_command_argument ( idx , length = length , status = stat ) if ( stat /= 0 ) then return endif allocate ( character ( len = length ) :: arg , stat = stat ) if ( stat /= 0 ) then return endif if ( length > 0 ) then call get_command_argument ( idx , arg , status = stat ) if ( stat /= 0 ) then deallocate ( arg ) return end if end if end subroutine get_argument subroutine get_arguments ( input , input_format , output , output_format , normalize , & & error ) !> Input file name character ( len = :), allocatable :: input !> Input file format integer , allocatable , intent ( out ) :: input_format !> Output file name character ( len = :), allocatable :: output !> Output file format integer , allocatable , intent ( out ) :: output_format !> Normalize element symbols logical , intent ( out ) :: normalize !> Error handling type ( error_type ), allocatable , intent ( out ) :: error integer :: iarg , narg character ( len = :), allocatable :: arg normalize = . false . iarg = 0 narg = command_argument_count () do while ( iarg < narg ) iarg = iarg + 1 call get_argument ( iarg , arg ) select case ( arg ) case ( \"--help\" ) call help ( output_unit ) stop case ( \"--version\" ) call version ( output_unit ) stop case default if (. not . allocated ( input )) then call move_alloc ( arg , input ) cycle end if if (. not . allocated ( output )) then call move_alloc ( arg , output ) cycle end if call fatal_error ( error , \"Too many positional arguments present\" ) exit case ( \"-i\" , \"--input\" ) iarg = iarg + 1 call get_argument ( iarg , arg ) if (. not . allocated ( arg )) then call fatal_error ( error , \"Missing argument for input format\" ) exit end if input_format = get_filetype ( \".\" // arg ) case ( \"-o\" , \"--output\" ) iarg = iarg + 1 call get_argument ( iarg , arg ) if (. not . allocated ( arg )) then call fatal_error ( error , \"Missing argument for output format\" ) exit end if output_format = get_filetype ( \".\" // arg ) case ( \"--normalize\" ) normalize = . true . end select end do if (. not .( allocated ( input ). and .( allocated ( output )))) then if (. not . allocated ( error )) then call help ( output_unit ) error stop end if end if end subroutine get_arguments end program main","tags":"","loc":"program/main.html"}]}